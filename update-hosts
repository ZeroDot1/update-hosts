#!/usr/bin/env bash
# Author:
#  Héctor Molinero Fernández <me@znt.se>.
#
# Modified by:
#  pyamsoft <pyam(dot)soft(at)gmail(dot)com>

# Exit on errors:
# For more information about these particular options, see
#    https://stackoverflow.com/questions/13468481/when-to-use-set-e
set -eu
set -o pipefail

# Configuration:
blocklist="" # Leave this blank
hosts="" # Leave this blank
dst_hosts="/etc/hosts"
dst_backup="${dst_hosts}.backup.$(date +%Y%m%d)"
dst_ip="0.0.0.0"
# NOTE: Adding the alias of the 0 domain to itself fixes a display issue that
#       can occur when using traceroute, netstat and the like.
header="
127.0.0.1 $(uname -n) localhost
255.255.255.255 broadcasthost
0.0.0.0 0.0.0.0
"
sources=(
	"http://winhelp2002.mvps.org/hosts.txt"
	"http://someonewhocares.org/hosts/hosts"
	"http://hosts-file.net/ad_servers.txt" # Ad servers only
	"http://hosts-file.net/download/hosts.txt" # The full host list, blocks malicious domains
	"http://hosts-file.net/hphosts-partial.txt" # Any updates to the hosts-file.net hosts file since the point release
	"http://www.malwaredomainlist.com/hostslist/hosts.txt"
	"http://pgl.yoyo.org/adservers/serverlist.php?hostformat=hosts&mimetype=plaintext"
	"http://adaway.org/hosts.txt"
	"http://malwaredomains.lehigh.edu/files/justdomains"
)

whitelist=(
	# DO NOT REMOVE, WHITELIST must always contain an entry
	# I use example.com as it will always route to an example webpage
	"example.com"
	# Fixes loading problems with some sites
	# "google-analytics.com"
	# "www.google-analytics.com"
	# "ssl.google-analytics.com"
)
# BLACKLIST DOMAINS
#    agor.io: Jumpscare
#    pinion.gg: Ads in Counter Strike: Global Offensive and other games
blacklist=(
	"agor.io"
	"www.agor.io"
	"adback.pinion.gg"
	"api.pinion.gg"
	"bin.pinion.gg"
	"blog.pinion.gg"
	"bork.pinion.gg"
	"calendar.pinion.gg"
	"cdn.pinion.gg"
	"cp.pinion.gg"
	"crm.pinion.gg"
	"delivery.pinion.gg"
	"direct.pinion.gg"
	"docs.pinion.gg"
	"immuniser.pinion.gg"
	"kermit.pinion.gg"
	"legacy.pinion.gg"
	"log.pinion.gg"
	"mail.pinion.gg"
	"mailer.pinion.gg"
	"motd.pinion.gg"
	"ns1.pinion.gg"
	"ns2.pinion.gg"
	"ns3.pinion.gg"
	"ns4.pinion.gg"
	"ns5.pinion.gg"
	"ns6.pinion.gg"
	"office.pinion.gg"
	"oscar.pinion.gg"
	"pinion-log.pinion.gg"
	"pinion.gg"
	"pog.pinion.gg"
	"quartermaster.pinion.gg"
	"seen.pinion.gg"
	"stage.pinion.gg"
	"templ4d2.pinion.gg"
	"tix.pinion.gg"
	"transcoded.pinion.gg"
	"video.pinion.gg"
	"voip.pinion.gg"
	"wiki.pinion.gg"
	"www.pinion.gg"
)

##
# Display a general message
##
action_msg() {
	printf "%b + %b%s%b\n" "\e[1;33m" "\e[1;32m" "$1" "\e[0m"
}

##
# Display an information snippet
##
info_msg() {
	printf "   - %s\n" "$1"
}

##
# Check the environment path for the either wget or curl, exit if it is not found
##
check_for_download_ability() {
	if ! which curl > /dev/null 2>&1; then
		if ! which wget > /dev/null 2>&1; then
			printf "Either wget or curl are required for operation of this script\n"
			printf "Please install either 'wget' or 'curl' onto your system.\n"
			exit 1
		fi
	fi
}

##
# Check the environment path for the given binary, exit if it is not found
##
check_for_binary() {
	if ! which "$1" > /dev/null 2>&1; then
		printf "The '%s' binary is required for operation of this script.\n" "$1"
		printf "Please install '%s' onto your system.\n" "$1"
		exit 1
	fi
}

##
# Print out the user configuration
##
print_config() {
	info_msg "Hosts location: ${dst_hosts}"
	info_msg "Destination IP: ${dst_ip}"
}

##
# Sources list parsing
##
download_sources() {
	# Check for curl, if not found, use wget, as the check for either
	# Should have passed before this function
	if which curl > /dev/null 2>&1; then
		local dl_client="curl"
		local cmd="${dl_client} -fsSL --connect-timeout 40 --max-time 60"
	else
		local dl_client="wget"
		local cmd="${dl_client} -T 10 -qO-"
	fi

	# Use the $dl_client to download the hosts files
	info_msg "Using ${dl_client} for downloading"
	for url in "${sources[@]}"; do
		info_msg "${url}"
		local content=$(${cmd} "${url}")
		# Inform user if the download fails or has no content
		if [[ -z "$content" ]]; then
			printf "\t%s\n" "URL: '${url}' failed to download or is empty."
			# exit 1
		fi
		blocklist=$(printf "%s\n%s\n" "${blocklist}" "${content}")
		unset content
	done
	unset cmd dl_client
}

##
# Change EOL from DOS to Unix format
##
change_eol() {
	info_msg "Change EOL to Unix format"
	blocklist=$(printf "%s\n" "${blocklist}" | sed 's/$//')
}

##
# Only select lines which contain a host, do not select comments/other
##
select_host_lines() {
	info_msg "Select only hosts lines"
	local ip_regex='([0-9]{1,3}\.){3}[0-9]{1,3}[[:blank:]]+'
	local domain_regex='([[:alnum:]_-]{1,63}\.)+[[:alpha:]][[:alnum:]_-]{1,62}'
	blocklist=$(printf '%s\n' "${blocklist}" | grep -oE "(^(${ip_regex})|^)${domain_regex}")
	unset ip_regex domain_regex

}

##
# Remove any predefined destinations, as they may be untrustworthy
##
remove_untrusted_domain() {
	info_msg "Remove old destination"
	blocklist=$(printf "%s\n" "${blocklist}" | sed -r 's/^([0-9]{1,3}\.){3}[0-9]{1,3}[[:space:]]+//g')
}

##
# Normalize all entries to lowercase strings
##
normalize_to_lowercase() {
	info_msg 'Transform all entries to lowercase'
	blocklist=$(printf "%s\n" "${blocklist}" | awk '{print tolower($0)}')
}

##
# Remove any entries containing the localhost, as it will be added by the header later on
##
remove_local_entries() {
	info_msg "Remove local entries"
	blocklist=$(printf "%s\n" "${blocklist}" | grep -Ev '^(localhost|localhost.localdomain|local|broadcasthost)$')
}

##
# Apply the user whitelist
##
apply_whitelist() {
	info_msg "Apply whitelist"
	for domain in "${whitelist[@]}"; do
		blocklist=$(printf "%s\n" "${blocklist}" | grep -Fxv "${domain}")
	done
}

##
# Apply the user blacklist
##
apply_blacklist() {
	infoMsg "Apply blacklist"
	# Cache the blacklist domains so that the entire block list
	# does not have to be echoed each time.
	# Fix an issue which adds a rogue newline into the blacklist,
	# creating an blank entry in the hosts file of
	# 0.0.0.0 <space>

	# Domains initialized as first blacklist entry
	local domains="${blacklist[0]}"
	# Only loop if the blacklist is multiple entries
	if [[ "${#blacklist[@]}" -gt 1 ]]; then
		for domain in "${blacklist[@]:1}"; do
			domains=$(printf "%s\n%s\n" "${domains}" "${domain}")
		done
	fi
	blocklist=$(printf "%s\n%s\n" "${blocklist}" "${domains}")
	unset domains
}

##
# Remove duplicate entries
##
remove_duplicates() {
	info_msg "Remove duplicate entries"
	blocklist=$(printf "%s\n" "${blocklist}" | awk '!a[$0]++')
}

##
# Sort the entries by string numerical value
##
sort_entries() {
	info_msg "Sort entries"
	blocklist=$(printf "%s\n" "${blocklist}" | sort -n)
}

##
# Add the configured destination, by default the zero address
##
add_new_destination() {
	info_msg "Add new destination"
	blocklist=$(printf "%s\n" "${blocklist}" | sed "s/^/${dst_ip} /g")
}

##
# Parse the header and create the new hosts file
##
generate_new_hosts_file() {
	header=$(printf "# <header>%s# </header>\n" "${header}")
	header=$(printf "# %s\n%s\n" "$(date)" "${header}")
	hosts=$(printf "%s\n# <blocklist>\n%s\n# </blocklist>" "${header}" "${blocklist}")
}

##
# Backup original hosts file
##
backup_old_hosts_file() {
	info_msg "Creating backup of original hosts file..."
	if [ "${EUID}" -ne 0 ]; then
		sudo cp "${dst_hosts}" "${dst_backup}"
	else
		cp "${dst_hosts}" "${dst_backup}"
	fi
}

##
# Install the new hosts file to the destination
##
install_new_hosts_file() {
	info_msg "Installing new hosts file..."
	if [ "${EUID}" -ne 0 ]; then
		printf "%s\n" "${hosts}" | sudo tee "${dst_hosts}" > /dev/null
	else
		printf "%s\n" "${hosts}" | tee "${dst_hosts}" > /dev/null
	fi
}

##
# Fixes permission on file to 644
##
fix_file_permissons() {
	info_msg "Fixing permissions for file $1..."
	if [ "${EUID}" -ne 0 ]; then
		sudo chmod 644 "$1"
	else
		chmod 644 "$1"
	fi
}

##
# Print the differences between the number of hosts in each file
##
print_hosts_file_differences() {
	local old_hosts_number=$(wc -l < ${dst_backup})
	local new_hosts_number=$(wc -l < ${dst_hosts})
	printf "%b + %b%s %bhosts added! (%b + %b%s %b)\n" \
		"\e[1;33m" "\e[1;32m" "${new_hosts_number}" \
		"\e[0m" "\e[1;32m" "\e[1;34m" \
		"$((new_hosts_number - old_hosts_number))" "\e[0m"
	unset old_hosts_number new_hosts_number
}


# Script begins here

# Check for required binaries, exit out if they are not present
check_for_download_ability
check_for_binary sudo
check_for_binary sed
check_for_binary grep
check_for_binary sort
check_for_binary awk
check_for_binary tee
check_for_binary cp
check_for_binary wc
check_for_binary printf
check_for_binary chmod

# Process begins:
action_msg "Configuration:"
print_config

action_msg "Downloading sources lists..."
download_sources

action_msg "Parsing sources lists..."
change_eol
select_host_lines
remove_untrusted_domain
normalize_to_lowercase
remove_local_entries
apply_whitelist
apply_blacklist
remove_duplicates
sorte_ntries
add_new_destination
generate_new_hosts_file

action_msg "Generating hosts file..."
backup_old_hosts_file
install_new_hosts_file
fix_file_permissons "${dst_hosts}"
fix_file_permissons "${dst_backup}"
print_hosts_file_differences

