#!/bin/sh

#
#  The MIT License (MIT)
#
#  Copyright (c) 2015 - 2016 Peter Kenji Yamanaka
#  Copyright (c) 2015 Héctor Molinero Fernández
#
#  Permission is hereby granted, free of charge, to any person obtaining a copy
#  of this software and associated documentation files (the "Software"), to deal
#  in the Software without restriction, including without limitation the rights
#  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#  copies of the Software, and to permit persons to whom the Software is
#  furnished to do so, subject to the following conditions:
#
#  The above copyright notice and this permission notice shall be included in all
#  copies or substantial portions of the Software.
#
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#  SOFTWARE.

# Author:
#  Héctor Molinero Fernández <me@znt.se>.
#
# Modified by:
#  pyamsoft <pyam(dot)soft(at)gmail(dot)com>

# Configuration:
readonly SUDOLOCK="/tmp/update-hosts.sudolock"

# NOTE: Adding the alias of the 0 domain to itself fixes a display issue that
#       can occur when using traceroute, netstat and the like.
readonly HOSTS_HEADER="
127.0.0.1 $(uname -n) localhost
255.255.255.255 broadcasthost
# Fixes a display anomaly in traceroute and netstat
0.0.0.0 0.0.0.0
"

# The base hosts_sources
# Provides a basic amount of protection without breaking sites, or breaking
# only a minimal amount of sites
readonly BASE_HOSTS_SOURCES="
  http://winhelp2002.mvps.org/hosts.txt
  http://someonewhocares.org/hosts/hosts
  https://www.malwaredomainlist.com/hostslist/hosts.txt
  https://pgl.yoyo.org/adservers/serverlist.php?hostformat=hosts&mimetype=plaintext
  https://adaway.org/hosts.txt
  https://www.malwaredomainlist.com/hostslist/hosts.txt
  https://s3.amazonaws.com/lists.disconnect.me/simple_ad.txt
  https://s3.amazonaws.com/lists.disconnect.me/simple_malvertising.txt
  https://s3.amazonaws.com/lists.disconnect.me/simple_malware.txt
  https://s3.amazonaws.com/lists.disconnect.me/simple_tracking.txt
"

# Additional hosts file servers
# readonly additonal_hosts_sources="
#   https://ransomwaretracker.abuse.ch/downloads/RW_DOMBL.txt
#   https://zeustracker.abuse.ch/blocklist.php?download=domainblocklist
# "

# Hosts-file.net server classifications
# Provides more in-depth protection and host blocking at the cost of
# breaking some sites
#
# readonly hosts_file_net_parts="
#   http://hosts-file.net/ad_servers.txt
#   http://hosts-file.net/emd.txt
#   http://hosts-file.net/exp.txt
#   http://hosts-file.net/fsa.txt
#   http://hosts-file.net/hjk.txt
#   http://hosts-file.net/mmt.txt
#   http://hosts-file.net/psh.txt
# "

# These entries are very large, and may break certain sites
# that rely on CDNs or third party hosts_sources
# Instead of downloading the entire hosts file and additional parts
# the split download above is recommended. The parts that you do not
# desire can be ignored individually instead of an all or nothing approach.
# The two hosts_sources below are generally not recommended nor needed. If you do
# wish to use them, be sure to comment out the above hosts-file.net entries
# or you will largely be pulling duplicate hosts_sources.
#
# readonly hosts_file_net_full="
#   http://hosts-file.net/download/hosts.txt
#   http://hosts-file.net/hphosts-partial.txt
# "


# The hosts_sources that will be parsed into the hosts file.
# By default only the hosts_sources in the ${BASE_HOSTS_SOURCES} list
# are included, additional hosts_sources can be included by
# appending them onto lines following the base-hosts_sources line.
# Destinations and duplicate entries do not matter, as they will
# be sanitized and duplicates will be stripped out.
readonly HOSTS_SOURCES="

  ${BASE_HOSTS_SOURCES}

"

# Regex allowed
#  '\.com$'   -> all domains that end with '.com'
#  '^example' -> all domains that start with 'example'
#  '^sub.\example\.org$' -> literal domain 'sub.exmaple.org'

# Due to the binary yes or no nature of hosts file, all of the domains that
# relate in some way to the uBlock0 Unbreak list will be added here.
# This is to allow uBlock0 to block the specific parts of the domains, while
# not breaking other sites that actually rely on them
# Though not a great solution, this seems to be the only way to get around
# some sites breaking when blocking certain hosts
#
# Update 2016/03/15
readonly HOSTS_WHITELIST='
  google-analytics\.com$
  ^analytics\.google\.com$
  adf\.ly$
  ^widget-cdn\.rpxnow\.com$
  ^tags\.tiqcdn\.com$
  statcounter\.com$
  ^cdn-static\.liverail\.com$
  ^vox-static\.liverail\.com$
  ^s0\.2mdn\.net$
  ^cdn-i\.dmdentertainment\.com$
  ^cdn\.vurb\.com$
  ^target\.122\.2o7\.net$
  ^adm\.fwmrm\.net$
  mopub\.com$
  safelinking\.net$
  outbrain\.com$
  inc\.com$
  flurry\.com$
  ^c\.speedtest\.net$
  boldchat\.com$
  mixpanel\.com$
  ^charlie\.strim.io$
  ^ovh\.strim.io$
  cdn\.turner\.com$
  ^yui\.yahooapis\.com$
  ^top\.mail\.ru$
  ^css\.washingtonpost\.com$
  pcekspert\.com$
  clickbank\.com$
  yandex\.ru$
  yastatic\.net$
  carbonads\.net$
  ^imasdk\.googleapis\.com$
  2o7\.net$
  quantcast\.com$
  ^css5\.gaanacdn\.com$
  ^keen\.github\.io$
  ^cdn\.phoenix\.intergi\.com$
  kissmetrics\.com$
  viewpoint\.com$
  woopra\.com$
  monetate\.net$
  ^googleads\.g\.doubleclick\.net$
  ^img\.echohosting\.cafe24\.com$
  googletagmanager\.com$
  ^partner\.googleadservices\.com$
  pagefair\.com$
  ^ssl\.cdn-redfin\.com$
  ^www\.southwest\.com$
  marketwatch\.com$
  cloudfront\.net$
  nationalreview\.com$
  liveperson\.net$
  taboola\.com$
  ^ticketmaster\.122\.2o7\.net$
  phoronix\.com$
  ^files\.explosm\.net$
  ^cdn\.segment\.com$
  sorted\.org$
  ^\analytics\.edgekey\.net$
  tfag\.de$
  ^nav\.files\.bbci\.co\.uk$
  gamespot\.com$
  umbro\.com$
  ^shop\.puppetlabs\.com$
  flightradar24\.com$
  ^premium\.soundcloud\.com$
  ^stats\.bbc\.co\.uk$
  snoobi\.com$
  esellerate\.net$
  ^dw\.cbsi\.com$
'

# hosts_blacklist DOMAINS
# Only exact strings, no regex supported
#    agor.io: Jumpscare
#    pinion.gg: Ads in Counter Strike: Global Offensive and other games
readonly HOSTS_BLACKLIST='
  agor.io
  www.agor.io
  adback.pinion.gg
  api.pinion.gg
  bin.pinion.gg
  blog.pinion.gg
  bork.pinion.gg
  calendar.pinion.gg
  cdn.pinion.gg
  cp.pinion.gg
  crm.pinion.gg
  delivery.pinion.gg
  direct.pinion.gg
  docs.pinion.gg
  immuniser.pinion.gg
  kermit.pinion.gg
  legacy.pinion.gg
  log.pinion.gg
  mail.pinion.gg
  mailer.pinion.gg
  motd.pinion.gg
  ns1.pinion.gg
  ns2.pinion.gg
  ns3.pinion.gg
  ns4.pinion.gg
  ns5.pinion.gg
  ns6.pinion.gg
  office.pinion.gg
  oscar.pinion.gg
  pinion-log.pinion.gg
  pinion.gg
  pog.pinion.gg
  quartermaster.pinion.gg
  seen.pinion.gg
  stage.pinion.gg
  templ4d2.pinion.gg
  tix.pinion.gg
  transcoded.pinion.gg
  video.pinion.gg
  voip.pinion.gg
  wiki.pinion.gg
  www.pinion.gg
'

# The base ipsets
# Provides a basic amount of protection without breaking sites, or breaking
# only a minimal amount of sites
readonly BASE_IPSET_SOURCES="
    http://www.projecthoneypot.org/list_of_ips.php?t=d&rss=1
    http://danger.rulez.sk/projects/bruteforceblocker/blist.php
    http://cinsscore.com/list/ci-badguys.txt
    http://blocklist.greensnow.co/greensnow.txt
    https://www.openbl.org/lists/base.txt
    https://www.autoshun.org/files/shunlist.csv
    https://lists.blocklist.de/lists/all.txt
    https://www.stopforumspam.com/downloads/toxic_ip_cidr.txt
    https://www.spamhaus.org/drop/drop.lasso
    https://check.torproject.org/cgi-bin/TorBulkreturnList.py?ip=1.1.1.1
    https://www.maxmind.com/en/proxy-detection-sample-list
"

# The sources that will be parsed into the ipset.
# By default only the sources in the ${base_sources} list
# are included, additional sources can be included by
# appending them onto lines following the base-sources line.
# Destinations and duplicate entries do not matter, as they will
# be sanitized and duplicates will be stripped out.
readonly IPSET_SOURCES="

  ${BASE_IPSET_SOURCES}

"
readonly IPSET_WHITELIST='
127.0.0.1
0.0.0.0
255.255.255.255
'

# BLACKLIST IPS
# Only exact strings, no regex supported
readonly IPSET_BLACKLIST='
'

# Some regular expressions for handling host names and IP addresses
readonly REGEX_STRIP_IP_ADDRESS='([0-9]{1,3}\.){3}[0-9]{1,3}[[:blank:]]+'
readonly REGEX_SELECT_IP_ADDRESS='([0-9]{1,3}\.){3}[0-9]{1,3}'
readonly REGEX_SELECT_HOST_NAME='([[:alnum:]_-]{1,63}\.)+[[:alpha:]][[:alnum:]_-]{1,62}'

##
# Display a general message
##
action_msg()
{
  action_msg__message="$1"

  printf -- "%b + %b%s%b\n" \
    "\033[1;33m" \
    "\033[1;32m" \
    "${action_msg__message}" \
    "\033[0m"

  unset action_msg__message
  return 0
}

##
# Display an error message
##
error_msg()
{
  error_msg__message="$1"

  printf -- "%b + %b%s%b\n" \
    "\033[1;33m" \
    "\033[1;31m" \
    "${error_msg__message}" \
    "\033[0m"

  unset error_msg__message
  return 0
}

##
# Display an information snippet
##
info_msg()
{
  info_msg__message="$1"

  printf -- "   - %s\n" \
    "${info_msg__message}"

  unset info_msg__message
  return 0
}

##
# Check the environment path for the either wget or curl
# return if it is not found
##
check_for_download_ability()
{
  if ! which curl > /dev/null 2>&1; then
    if ! which wget > /dev/null 2>&1; then
      printf -- "Either wget or curl are required for this script\n"
      printf -- "Please install either 'wget' or 'curl' onto your system.\n"

      return 1
    fi
  fi

  return 0
}

##
# Check the environment path for the given binary, return if it is not found
#
# $1 the binary to check on the PATH
##
check_for_binary()
{
  check_for_binary__bin="$1"

  if ! which "${check_for_binary__bin}" > /dev/null 2>&1; then
    printf -- "The '%s' binary is required for this script.\n" \
      "${check_for_binary__bin}"
    printf -- "Please install '%s' onto your system.\n" \
      "${check_for_binary__bin}"

    unset check_for_binary__bin
    return 1
  fi

  unset check_for_binary__bin
  return 0
}

##
# Print out the hosts configuration
#
# $1 hosts file location
# $2 hosts destination IP
##
print_hosts_config()
{
  print_hosts_config__file="$1"
  print_hosts_config__ip="$2"

  action_msg "Hosts Configuration:"
  info_msg "Hosts location: ${print_hosts_config__file}"
  info_msg "Destination IP: ${print_hosts_config__ip}"

  unset print_hosts_config__file
  unset print_hosts_config__ip
  return 0
}

##
# Print out the ipset configuration
#
# $1 sudo or blank if not needed
# $2 ipset file location
# $3 ipset name
##
print_ipset_config()
{
  print_ipset_config__sudo="$1"
  print_ipset_config__file="$2"
  print_ipset_config__name="$3"

  action_msg "Ipset Configuration:"
  info_msg "Ipset location: ${print_ipset_config__file}"
  info_msg "Ipset name: ${print_ipset_config__name}"

  # The ipset must exist first for this script to work
  # check for existence here
  ${print_ipset_config__sudo} ipset list "${print_ipset_config__name}" > /dev/null 2>&1 || {
    error_msg "The ipset: ${print_ipset_config__name} must exist before running this script."
    error_msg "Create it using: # ipset create ${print_ipset_config__name}"

    unset print_ipset_config__sudo
    unset print_ipset_config__file
    unset print_ipset_config__name
    return 1
  }

  unset print_ipset_config__sudo
  unset print_ipset_config__file
  unset print_ipset_config__name
  return 0
}

##
# Decide what program to DL with
#
# Echoes the name of the program to use as an HTTP client for downloading the
# sources
##
decide_dl_client()
{
  # Check for curl, if not found, use wget, as the check for either
  # Should have passed before this function
  decide_dl_client__cmd=

  if which curl > /dev/null 2>&1; then
    decide_dl_client__cmd="curl -fsSL --connect-timeout 40 --max-time 60 -A 'Mozilla/5.0'"
  else
    decide_dl_client__cmd="wget -T 10 -qO- -A 'Mozilla/5.0'"
  fi

  # Echo before unsetting
  printf -- "%s" "${decide_dl_client__cmd}"

  unset decide_dl_client__cmd
  return 0
}

##
# Process each temporary Ipset source file
#
# $1 temporary file location
# $2 source url
##
process_ipset_sources()
{
  process_ipset_sources__file="$1"
  process_ipset_sources__url="$2"

  change_eol "${process_ipset_sources__file}" "${process_ipset_sources__url}"
  select_ip_lines "${process_ipset_sources__file}" "${process_ipset_sources__url}"

  unset process_ipset_sources__file
  unset process_ipset_sources__url
  return 0
}

##
# Process each temporary hosts source file
#
# $1 temporary file location
# $2 source url
##
process_hosts_sources()
{
  process_hosts_sources__file="$1"
  process_hosts_sources__url="$2"

  change_eol "${process_hosts_sources__file}" "${process_hosts_sources__url}"
  select_host_lines "${process_hosts_sources__file}" "${process_hosts_sources__url}"
  remove_untrusted_domain "${process_hosts_sources__file}" "${process_hosts_sources__url}"
  normalize_to_lowercase "${process_hosts_sources__file}" "${process_hosts_sources__url}"
  remove_local_entries "${process_hosts_sources__file}" "${process_hosts_sources__url}"

  unset process_hosts_sources__file
  unset process_hosts_sources__url
  return 0
}

##
# Parse the hosts file together from the various sources
#
# $1 The HTTP client to use
# $2 The URL of the source
# $3 The temporary file location
# $4 The command to run after downloading, begins with process_*
##
download_to_tempfile()
{
  download_to_tempfile__client="$1"
  download_to_tempfile__url="$2"
  download_to_tempfile__file="$3"
  download_to_tempfile__process_hook="$4"
  download_to_tempfile__content=

  info_msg "Downloading from ${download_to_tempfile__url}"
  download_to_tempfile__content="$(printf -- "%s" "$(${download_to_tempfile__client} "${download_to_tempfile__url}")")"
  if [ -z "${download_to_tempfile__content}" ]; then
    info_msg "  Failed to download from: ${download_to_tempfile__url}"
    return 1
  fi

  # Guarantee an empty file
  printf -- "%s\n" "${download_to_tempfile__content}" > "${download_to_tempfile__file}"

  # Run after download processing hook
  "${download_to_tempfile__process_hook}" "${download_to_tempfile__file}" "${download_to_tempfile__url}"

  unset download_to_tempfile__client
  unset download_to_tempfile__process_hook
  unset download_to_tempfile__url
  unset download_to_tempfile__file
  unset download_to_tempfile__content
  return 0
}


##
# Download the source file from each URL specified in source
# Download runs in parallel in the background
#
# $1 The HTTP client to use
# $2 The sources list to download from
# $3 Name of the function to call after download, begins with process_*
##
download_sources()
{
  download_sources__client="$1"
  download_sources__sources="$2"
  download_sources__process_hook="$3"

  for download_sources__url in ${download_sources__sources}; do
    download_sources__tempfile=
    download_sources__tempfile="$(mktemp)"

    # Add the tempfile to list of temporary files
    __temp_files="${download_sources__tempfile} "${__temp_files}

    download_to_tempfile "${download_sources__client}" "${download_sources__url}" "${download_sources__tempfile}" "${download_sources__process_hook}" &

    # Add the pid to list of pids
    __pids="${__pids} $!"

    unset download_sources__tempfile
    unset download_sources__url
  done

  # Wait for all parallel downloads to finish
  # Instead of taking a long time in total, this will only take as long
  # as it takes for the longest download to complete
  #
  # Do not quote so that this will split into a list, instead of a single,
  # space separated input
  # shellcheck disable=SC2086
  wait ${__pids}

  # Write the contents of each download to the blocklist
  for f in ${__temp_files}; do
    download_sources__tempfile_content=

    download_sources__tempfile_content="$(cat "$f")"
    if [ ! -z "${download_sources__tempfile_content}" ]; then
      if [ -z "${__blocklist}" ]; then
        __blocklist="$(printf -- "%s\n" \
          "${download_sources__tempfile_content}")"
      else
        __blocklist="$(printf -- "%s\n%s\n" \
          "${__blocklist}" \
          "${download_sources__tempfile_content}")"
      fi
    fi

    # Remove the temp file
    rm -f "$f"

    unset f
    unset download_sources__tempfile_content
  done

  unset download_sources__client
  unset download_sources__sources
  unset download_sources__process_hook
  return 0
}

##
# Change EOL from DOS to Unix format
#
# $1 file location
# $2 source url
##
change_eol()
{
  change_eol__file="$1"
  change_eol__url="$2"
  info_msg "Change EOL to Unix format: ${change_eol__url} (${change_eol__file})"
  sed -r -i 's/$//' "${change_eol__file}"

  unset change_eol__file
  unset change_eol__url
  return 0
}

##
# Only select lines which contain a host, do not select comments/other
#
# $1 file location
# $2 source url
##
select_host_lines()
{
  select_host_lines__file="$1"
  select_host_lines__url="$2"


  # KLUDGE
  # This leaves trailing comments in lines, making it not as effective
  # sed -n -i -r "/(^(${ip_regex})|^)${domain_regex}/p" "$1"
  #
  # This is an ugly workaround
  info_msg "Select only hosts lines: ${select_host_lines__url} (${select_host_lines__file})"

  select_host_lines__content=
  select_host_lines__content="$(grep -oE \
    "(^(${REGEX_STRIP_IP_ADDRESS})|^)${REGEX_SELECT_HOST_NAME}" \
    "${select_host_lines__file}")"

  # Echo out result
  printf -- "${select_host_lines__content}" > "${select_host_lines__file}"

  unset select_host_lines__file
  unset select_host_lines__url
  unset select_host_lines__content
  return 0
}

##
# Only select lines which contain an ip, do not select comments/other
#
# $1 file location
# $2 source url
##
select_ip_lines()
{
  select_ip_lines__file="$1"
  select_ip_lines__url="$2"

  info_msg "Select only IP lines: ${select_ip_lines__url} (${select_ip_lines__file})"
  select_ip_lines__content=
  select_ip_lines__content="$(grep -oE "${REGEX_SELECT_IP_ADDRESS}" \
    "${select_ip_lines__file}")"

  # Echo out result
  printf -- "${select_ip_lines__content}" > "${select_ip_lines__file}"

  unset select_ip_lines__content
  unset select_ip_lines__file
  unset select_ip_lines__url
  return 0
}

##
# Remove any predefined destinations, as they may be untrustworthy
#
# $1 file
# $2 url
##
remove_untrusted_domain()
{
  remove_untrusted_domain__file="$1"
  remove_untrusted_domain__url="$2"
  info_msg "Remove old destination: ${remove_untrusted_domain__url} (${remove_untrusted_domain__file})"
  sed -i -r 's/^([0-9]{1,3}\.){3}[0-9]{1,3}[[:space:]]+//g' "${remove_untrusted_domain__file}"

  unset remove_untrusted_domain__file
  unset remove_untrusted_domain__url
  return 0
}

##
# Normalize all entries to lowercase strings
#
# $1 file
# $2 url
##
normalize_to_lowercase()
{
  normalize_to_lowercase__file="$1"
  normalize_to_lowercase__url="$2"
  # KLUDGE
  # Awk for some reason stops parsing after 1024 lines
  # awk -v tf="$1" '{print tolower($0) > tf}' "$1"
  #
  # This is an ugly work around
  info_msg "Transform all entries to lowercase: ${normalize_to_lowercase__url} (${normalize_to_lowercase__file})"

  normalize_to_lowercase__content=
  normalize_to_lowercase__content="$(awk '{print tolower($0)}' "${normalize_to_lowercase__file}")"
  printf -- "${normalize_to_lowercase__content}" > "${normalize_to_lowercase__file}"

  unset normalize_to_lowercase__file
  unset normalize_to_lowercase__url
  unset normalize_to_lowercase__content
  return 0
}

##
# Remove any entries containing the localhost, as it will be added by
# the hosts_header later on
#
# $1 file
# $2 url
##
remove_local_entries()
{
  remove_local_entries__file="$1"
  remove_local_entries__url="$2"

  info_msg "Remove local entries: ${remove_local_entries__url} (${remove_local_entries__file})"
  sed -n -i -r '/^(localhost|localhost.localdomain|local|broadcasthost)$/!p' \
    "${remove_local_entries__file}"

  unset remove_local_entries__file
  unset remove_local_entries__url
  return 0
}

##
# Apply the user hosts_whitelist
#
# $1 whitelist
##
apply_whitelist()
{
  apply_whitelist__whitelist="$1"

  info_msg "Apply hosts_whitelist"
  if [ -z "${__blocklist}" ]; then
    error_msg "Block list is empty"
    return 1
  fi

  for apply_whitelist__domain in ${apply_whitelist__whitelist}; do
    __blocklist="$(printf -- "%s\n" "${__blocklist}" | sed -r "/${apply_whitelist__domain}/d")"
    unset apply_whitelist__domain
  done

  unset apply_whitelist__whitelist
  return 0
}

##
# Apply the user blacklist
#
# $1 blacklist
##
apply_blacklist()
{
  apply_blacklist__blacklist="$1"

  info_msg "Apply hosts_blacklist"
  # Cache the hosts_blacklist domains so that the entire block list
  # does not have to be echoed each time.
  # Domains initialized as first hosts_blacklist entry
  apply_blacklist__domains=""

  for apply_blacklist__domain in ${apply_blacklist__blacklist}; do
    if [ -z "${apply_blacklist__domains}" ]; then
      apply_blacklist__domains="${apply_blacklist__domain}"
    else
      apply_blacklist__domains="$(printf -- "%s\n%s\n" \
        "${apply_blacklist__domains}" \
        "${apply_blacklist__domain}")"
    fi
  done

  if [ -z "${__blocklist}" ]; then
    __blocklist="$(printf -- "%s\n" "${apply_blacklist__domains}")"
  else
    __blocklist="$(printf -- "%s\n%s\n" "${__blocklist}" "${apply_blacklist__domains}")"
  fi

  unset apply_blacklist__domains
  unset apply_blacklist__blacklist
  return 0
}

##
# Remove duplicate entries
##
remove_duplicates()
{
  info_msg "Remove duplicate entries"
  __blocklist="$(printf -- "%s\n" "${__blocklist}" | awk '!a[$0]++')"

  return 0
}

##
# Sort the entries by string numerical value
##
sort_entries()
{
  info_msg "Sort entries"
  __blocklist="$(printf -- "%s\n" "${__blocklist}" | sort -n)"

  return 0
}

##
# Add the configured destination, by default the zero address
#
# $1 desitination IP address
##
add_new_destination()
{
  add_new_destination__ip="$1"

  info_msg "Add new destination"
  __blocklist="$(printf -- "%s\n" "${__blocklist}" \
    | sed "s/^/${add_new_destination__ip} /g")"

  unset add_new_destination__ip
  return 0
}

##
# Parse the hosts_header and create the new hosts file
#
# Outputs the completed hosts file contents
##
generate_new_hosts_file()
{
  generate_new_hosts_file__header=

  info_msg "Create new hosts file"
  generate_new_hosts_file__header="$(printf -- "# <hosts_header>%s# </hosts_header>\n" "${HOSTS_HEADER}")"
  generate_new_hosts_file__header="$(printf -- "# %s\n%s\n" \
    "$(date)" \
    "${generate_new_hosts_file__header}")"

  printf -- "%s\n# <blocklist>\n%s\n# </blocklist>" \
    "${generate_new_hosts_file__header}" \
    "${__blocklist}"

  unset generate_new_hosts_file__header
  unset __blocklist
  return 0
}

##
# Backup original file
#
# $1 needs_sudo
# $2 file name
# $3 backup name
##
backup_old_file()
{
  backup_old_file__sudo="$1"
  backup_old_file__file="$2"
  backup_old_file__backup="$3"

  if [ -f "${backup_old_file__file}" ]; then
    info_msg "Creating backup of original file..."
    ${backup_old_file__sudo} cp "${backup_old_file__file}" "${backup_old_file__backup}" || {
      error_msg "Failed to copy to file ${backup_old_file__backup}"

      unset backup_old_file__sudo
      unset backup_old_file__file
      unset backup_old_file__backup
      return 1
    }
  else
    info_msg "No original file exists to create backup"
  fi

  unset backup_old_file__sudo
  unset backup_old_file__file
  unset backup_old_file__backup
  return 0
}

##
# Install the new hosts file to the destination
##
install_new_hosts_file()
{
  info_msg "Installing new hosts file..."
  printf -- "%s\n" "${hosts}" | ${needs_sudo} tee "${dst_hosts}" > /dev/null || {
    error_msg "Failed to output to file ${dst_hosts}"
    return 1
  }
}

install_ipset_blocklist()
{
  action_msg "Install the ipset blocklist"

  info_msg "Clear existing block list"
  printf -- "" | ${needs_sudo} tee "${dst_ipset}" > /dev/null
  ${needs_sudo} ipset flush "${ipset_name}"

  info_msg "Create new blocklist"
  # Save here just to get the create line
  ${needs_sudo} ipset save "${ipset_name}" -file "${dst_ipset}"

  info_msg "Add new IPs to the block list"
  blocklist=$(printf -- "%s\n" "${blocklist}" | sed -e 's/^/add blocklist /')
  printf -- "%s\n" "${blocklist}" | ${needs_sudo} tee -a "${dst_ipset}" > /dev/null || {
    error_msg "Failed to add ipset to blocklist"
    return 1
  }

  info_msg "Commit new ipset"
  ${needs_sudo} ipset restore -exist -file "${dst_ipset}"
}


##
# Fixes permission on file to 644
##
fix_file_permissons()
{
  if [ -f "$1" ]; then
    info_msg "Fixing permissions for file $1..."
    ${needs_sudo} chmod 644 "$1" || {
      error_msg "Failed to chmod $1"
      return 1
    }
  else
    info_msg "Cannot fix permission for non-existant file $1"
  fi
}

create_backup_name()
{
  # $1 file name
  printf -- "$1.backup.$(date +%Y%m%d)"
}

##
# Print the differences between the number of lines in each file
##
print_file_differences()
{
  # $1 new
  # $2 old
  local old_number=
  if [ -f "$2" ]; then
    old_number=$(wc -l < "$2")
  else
    old_number=0
  fi
  local new_number=$(wc -l < "$1")
  printf -- "%b + %b%s %bentries added! (%b + %b%s %b)\n" \
    "\033[1;33m" "\033[1;32m" "${new_number}" \
    "\033[0m" "\033[1;32m" "\033[1;34m" \
    "$((new_number - old_number))" "\033[0m"
  unset old_number new_number
}

remove_all_backup_files()
{
  # $1 normal file
  for arg in "$1".backup.*; do
    info_msg "Removing backup file: ${arg}..."
    ${needs_sudo} rm -f "${arg}" > /dev/null 2>&1
  done
}

sudoloop()
{
  touch "${SUDOLOCK}"
  while [ -e "${SUDOLOCK}" ]; do
    sudo -n -v
    sleep 2
  done
}

cleanup()
{
  # Kill runaway pids
  for p in ${pids}; do
    kill "${p}" > /dev/null 2>&1
  done

  # rm leftover files
  for temp in ${temp_files}; do
    rm -f "${temp}" > /dev/null 2>&1
  done

  blocklist=""
  pids=""
  temp_files=""
}

cancel_sudoloop()
{
  [ -e "${SUDOLOCK}" ] && rm -f "${SUDOLOCK}"

  cleanup

  # Exit point
  exit 0
}

print_version()
{
  printf -- "update-hosts[${version}]\n"
  echo
}

main()
{
  # For more information about these particular options, see
  #    https://stackoverflow.com/questions/13468481/when-to-use-set-e
  set -u

  # Export the LC as the default C so that we do not run into locale based quirks
  export LC_ALL=C

  # Version
  version="2.0.0"

  # Options
  remove_backups=0
  require_root=1
  manage_ipsets=0

  # Script begins here
  dst_hosts="/etc/hosts"
  dst_ipset="/etc/ipset.conf"
  ipset_name="blocklist"
  dst_ip="0.0.0.0"

  # Check for required binaries, return out if they are not present
  check_for_download_ability || return 1
  check_for_binary sed || return 1
  check_for_binary grep || return 1
  check_for_binary sort || return 1
  check_for_binary touch || return 1
  check_for_binary sleep || return 1
  check_for_binary rm || return 1
  check_for_binary awk || return 1
  check_for_binary tee || return 1
  check_for_binary cp || return 1
  check_for_binary wc || return 1
  check_for_binary printf || return 1
  check_for_binary chmod || return 1
  check_for_binary mktemp || return 1
  check_for_binary cat || return 1

  # Handle options
  # Options
  #   -h | --help     Display help
  #   -v | --version  Display version
  #   -r | --remove   Remove backups
  #   -n | --noroot   Do not require root to output.
  #   -i | --ipset    Also download ipset sources
  #   --output-hosts  The file to output hosts to
  #   --output-ipset  The file to output ipsets to
  #   --ipset-name    The name of the ipset
  #   --dest-ip       The destination IP to use
  for arg in "$@"; do
    case "${arg}" in
      "-h"|"--help")
        print_version
        printf -- "  Options:\n"
        printf -- "     -h | --help     Display help\n"
        printf -- "     -v | --version  Display version\n"
        printf -- "     -r | --remove   Remove backups\n"
        printf -- "     -n | --noroot   Do not require root to output\n"
        printf -- "     -i | --ipset    Also download ipset sources\n"
        printf -- "     --output-hosts  The file to output hosts to\n"
        printf -- "     --output-ipset  The file to output ipsets to\n"
        printf -- "     --ipset-name    The name of the ipset\n"
        printf -- "     --dest-ip       The destination IP to use\n"
        return 0
        ;;
      "-v"|"--version")
        print_version
        return 0
        ;;
      "-r"|"--remove")
        remove_backups=1
        shift
        ;;
      "--output-hosts")
        shift
        if [ $# -ge 1 ]; then
          if  [ -z "$1" ]; then
            error_msg "Must specify an output file name."
            return 1
          else
            dst_hosts="$1"
            shift
          fi
        else
          error_msg "Must specify an output file name."
          return 1
        fi
        ;;
      "--output-ipset")
        shift
        if [ $# -ge 1 ]; then
          if  [ -z "$1" ]; then
            error_msg "Must specify an output file name."
            return 1
          else
            dst_ipset="$1"
            shift
          fi
        else
          error_msg "Must specify an output file name."
          return 1
        fi
        ;;
      "--ipset-name")
        shift
        if [ $# -ge 1 ]; then
          if  [ -z "$1" ]; then
            error_msg "Must specify an ipset name."
            return 1
          else
            ipset_name="$1"
            shift
          fi
        else
          error_msg "Must specify an ipset name."
          return 1
        fi
        ;;
      "--dest-ip")
        shift
        if [ $# -ge 1 ]; then
          if  [ -z "$1" ]; then
            error_msg "Must specify an IP."
            return 1
          else
            dst_ip="$1"
            shift
          fi
        else
          error_msg "Must specify an IP."
          return 1
        fi
        ;;
      "-n"|"--noroot")
        require_root=0
        shift
        ;;
      "-i"|"--ipset")
        manage_ipsets=1
        shift
        ;;
    esac
  done

  # Trap return signals
  trap cancel_sudoloop INT

  needs_sudo=
  if [ "$(id -u)" -ne 0 ] && [ "${require_root}" -eq 1 ]; then
    check_for_binary sudo

    # initialize sudo
    sudo -v || return 1

    # Start sudoloop
    sudoloop &

    needs_sudo="sudo"
  else
    needs_sudo=""
  fi

  # Process begins:
  print_hosts_config "${dst_hosts}" "${dst_ip}" || cancel_sudoloop

  # Download
  action_msg "Downloading hosts_sources lists..."
  download_sources "$(decide_dl_client)" "${HOSTS_SOURCES}" "process_hosts_sources" || cancel_sudoloop

  # Parse
  action_msg "Generating hosts file..."
  apply_whitelist "blocklist" "${HOSTS_WHITELIST}" || cancel_sudoloop
  apply_blacklist "${HOSTS_BLACKLIST}" || cancel_sudoloop
  remove_duplicates || cancel_sudoloop
  sort_entries || cancel_sudoloop
  add_new_destination "${dst_ip}" || cancel_sudoloop

  # Install
  hosts=
  hosts="$(generate_new_hosts_file)" || cancel_sudoloop
  dst_backup="$(create_backup_name "${dst_hosts}")"
  backup_old_file "${needs_sudo}" "${dst_hosts}" "${dst_backup}" || cancel_sudoloop
  install_new_hosts_file || cancel_sudoloop
  fix_file_permissons "${dst_hosts}" || cancel_sudoloop
  fix_file_permissons "${dst_backup}" || cancel_sudoloop
  print_file_differences "${dst_hosts}" "${dst_backup}" || cancel_sudoloop

  # Cleanup
  if [ "${remove_backups}" -eq 1 ]; then
    remove_all_backup_files "${dst_hosts}" || cancel_sudoloop
  fi

  if [ "${manage_ipsets}" -eq 0 ]; then
    # End here
    cancel_sudoloop
  fi

  # Start fresh
  cleanup

  check_for_binary ipset || cancel_sudoloop

  # Download
  printf -- "\n\n"
  print_ipset_config "${needs_sudo}" "${dst_ipset}" "${ipset_name}" || return 1
  action_msg "Downloading ipset_sources lists..."
  download_sources "$(decide_dl_client)" "${IPSET_SOURCES}" "process_ipset_sources" || cancel_sudoloop

  # Parse
  action_msg "Generating ipset..."
  apply_whitelist "${IPSET_WHITELIST}" || cancel_sudoloop
  apply_blacklist "${IPSET_BLACKLIST}" || cancel_sudoloop
  remove_duplicates || cancel_sudoloop
  sort_entries || cancel_sudoloop

  # Install
  dst_backup=$(create_backup_name "${dst_ipset}" ) || cancel_sudoloop
  backup_old_file || cancel_sudoloop
  install_ipset_blocklist || cancel_sudoloop
  fix_file_permissons "${dst_ipset}" || cancel_sudoloop
  fix_file_permissons "${dst_backup}" || cancel_sudoloop
  print_file_differences "${dst_ipset}" "${dst_backup}" || cancel_sudoloop

  if [ "${remove_backups}" -eq 1 ]; then
    remove_all_backup_files "${dst_ipset}" || cancel_sudoloop
  fi

  # Finish
  cancel_sudoloop
}


__temp_files="" # Leave blank
__pids="" # Leave blank
__blocklist="" # Leave blank
main "$@"

# vim: set syntax=sh tabstop=2 softtabstop=2 shiftwidth=2 shiftround expandtab:

