#!/bin/sh

#
#  The MIT License (MIT)
#
#  Copyright (c) 2015 - 2016 Peter Kenji Yamanaka
#  Copyright (c) 2015 Héctor Molinero Fernández
#
#  Permission is hereby granted, free of charge, to any person obtaining a copy
#  of this software and associated documentation files (the "Software"), to deal
#  in the Software without restriction, including without limitation the rights
#  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#  copies of the Software, and to permit persons to whom the Software is
#  furnished to do so, subject to the following conditions:
#
#  The above copyright notice and this permission notice shall be included in all
#  copies or substantial portions of the Software.
#
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#  SOFTWARE.

# Author:
#  Héctor Molinero Fernández <me@znt.se>.
#
# Modified by:
#  pyamsoft <pyam(dot)soft(at)gmail(dot)com>

# For more information about these particular options, see
#    https://stackoverflow.com/questions/13468481/when-to-use-set-e
set -u

# Export the LC as the default C so that we do not run into locale based quirks
export LC_ALL=C

# Version
version="1.2.2"

# Configuration:
readonly sudolock="/tmp/update-hosts.sudolock"
readonly dst_ip="0.0.0.0"
readonly ipset_name="blocklist"
readonly ipset_file="/etc/ipset.conf"

temp_files=""
pids="" # Leave blank
blocklist="" # Leave this blank
hosts="" # Leave this blank

# Options
diff_file=0
remove_backups=0
display_pager=0
require_root=1

# NOTE: Adding the alias of the 0 domain to itself fixes a display issue that
#       can occur when using traceroute, netstat and the like.
hosts_header="
127.0.0.1 $(uname -n) localhost
255.255.255.255 broadcasthost
# Fixes a display anomaly in traceroute and netstat
0.0.0.0 0.0.0.0
"

# The base hosts_sources
# Provides a basic amount of protection without breaking sites, or breaking
# only a minimal amount of sites
readonly base_hosts_sources="
  http://winhelp2002.mvps.org/hosts.txt
  http://someonewhocares.org/hosts/hosts
  https://www.malwaredomainlist.com/hostslist/hosts.txt
  https://pgl.yoyo.org/adservers/serverlist.php?hostformat=hosts&mimetype=plaintext
  https://adaway.org/hosts.txt
  https://www.malwaredomainlist.com/hostslist/hosts.txt
  https://s3.amazonaws.com/lists.disconnect.me/simple_ad.txt
  https://s3.amazonaws.com/lists.disconnect.me/simple_malvertising.txt
  https://s3.amazonaws.com/lists.disconnect.me/simple_malware.txt
  https://s3.amazonaws.com/lists.disconnect.me/simple_tracking.txt
"

# Additional hosts file servers
# readonly additonal_hosts_sources="
#   https://ransomwaretracker.abuse.ch/downloads/RW_DOMBL.txt
#   https://zeustracker.abuse.ch/blocklist.php?download=domainblocklist
# "

# Hosts-file.net server classifications
# Provides more in-depth protection and host blocking at the cost of
# breaking some sites
#
# readonly hosts_file_net_parts="
#   http://hosts-file.net/ad_servers.txt
#   http://hosts-file.net/emd.txt
#   http://hosts-file.net/exp.txt
#   http://hosts-file.net/fsa.txt
#   http://hosts-file.net/hjk.txt
#   http://hosts-file.net/mmt.txt
#   http://hosts-file.net/psh.txt
# "

# These entries are very large, and may break certain sites
# that rely on CDNs or third party hosts_sources
# Instead of downloading the entire hosts file and additional parts
# the split download above is recommended. The parts that you do not
# desire can be ignored individually instead of an all or nothing approach.
# The two hosts_sources below are generally not recommended nor needed. If you do
# wish to use them, be sure to comment out the above hosts-file.net entries
# or you will largely be pulling duplicate hosts_sources.
#
# readonly hosts_file_net_full="
#   http://hosts-file.net/download/hosts.txt
#   http://hosts-file.net/hphosts-partial.txt
# "


# The hosts_sources that will be parsed into the hosts file.
# By default only the hosts_sources in the ${base_hosts_sources} list
# are included, additional hosts_sources can be included by
# appending them onto lines following the base-hosts_sources line.
# Destinations and duplicate entries do not matter, as they will
# be sanitized and duplicates will be stripped out.
readonly hosts_sources="

  ${base_hosts_sources}

"

# Regex allowed
#  '\.com$'   -> all domains that end with '.com'
#  '^example' -> all domains that start with 'example'
#  '^sub.\example\.org$' -> literal domain 'sub.exmaple.org'

# Due to the binary yes or no nature of hosts file, all of the domains that
# relate in some way to the uBlock0 Unbreak list will be added here.
# This is to allow uBlock0 to block the specific parts of the domains, while
# not breaking other sites that actually rely on them
# Though not a great solution, this seems to be the only way to get around
# some sites breaking when blocking certain hosts
#
# Update 2016/03/15
readonly hosts_whitelist='
  google-analytics\.com$
  ^analytics\.google\.com$
  adf\.ly$
  ^widget-cdn\.rpxnow\.com$
  ^tags\.tiqcdn\.com$
  statcounter\.com$
  ^cdn-static\.liverail\.com$
  ^vox-static\.liverail\.com$
  ^s0\.2mdn\.net$
  ^cdn-i\.dmdentertainment\.com$
  ^cdn\.vurb\.com$
  ^target\.122\.2o7\.net$
  ^adm\.fwmrm\.net$
  mopub\.com$
  safelinking\.net$
  outbrain\.com$
  inc\.com$
  flurry\.com$
  ^c\.speedtest\.net$
  boldchat\.com$
  mixpanel\.com$
  ^charlie\.strim.io$
  ^ovh\.strim.io$
  cdn\.turner\.com$
  ^yui\.yahooapis\.com$
  ^top\.mail\.ru$
  ^css\.washingtonpost\.com$
  pcekspert\.com$
  clickbank\.com$
  yandex\.ru$
  yastatic\.net$
  carbonads\.net$
  ^imasdk\.googleapis\.com$
  2o7\.net$
  quantcast\.com$
  ^css5\.gaanacdn\.com$
  ^keen\.github\.io$
  ^cdn\.phoenix\.intergi\.com$
  kissmetrics\.com$
  viewpoint\.com$
  woopra\.com$
  monetate\.net$
  ^googleads\.g\.doubleclick\.net$
  ^img\.echohosting\.cafe24\.com$
  googletagmanager\.com$
  ^partner\.googleadservices\.com$
  pagefair\.com$
  ^ssl\.cdn-redfin\.com$
  ^www\.southwest\.com$
  marketwatch\.com$
  cloudfront\.net$
  nationalreview\.com$
  liveperson\.net$
  taboola\.com$
  ^ticketmaster\.122\.2o7\.net$
  phoronix\.com$
  ^files\.explosm\.net$
  ^cdn\.segment\.com$
  sorted\.org$
  ^\analytics\.edgekey\.net$
  tfag\.de$
  ^nav\.files\.bbci\.co\.uk$
  gamespot\.com$
  umbro\.com$
  ^shop\.puppetlabs\.com$
  flightradar24\.com$
  ^premium\.soundcloud\.com$
  ^stats\.bbc\.co\.uk$
  snoobi\.com$
  esellerate\.net$
  ^dw\.cbsi\.com$
'

# hosts_blacklist DOMAINS
# Only exact strings, no regex supported
#    agor.io: Jumpscare
#    pinion.gg: Ads in Counter Strike: Global Offensive and other games
readonly hosts_blacklist='
  agor.io
  www.agor.io
  adback.pinion.gg
  api.pinion.gg
  bin.pinion.gg
  blog.pinion.gg
  bork.pinion.gg
  calendar.pinion.gg
  cdn.pinion.gg
  cp.pinion.gg
  crm.pinion.gg
  delivery.pinion.gg
  direct.pinion.gg
  docs.pinion.gg
  immuniser.pinion.gg
  kermit.pinion.gg
  legacy.pinion.gg
  log.pinion.gg
  mail.pinion.gg
  mailer.pinion.gg
  motd.pinion.gg
  ns1.pinion.gg
  ns2.pinion.gg
  ns3.pinion.gg
  ns4.pinion.gg
  ns5.pinion.gg
  ns6.pinion.gg
  office.pinion.gg
  oscar.pinion.gg
  pinion-log.pinion.gg
  pinion.gg
  pog.pinion.gg
  quartermaster.pinion.gg
  seen.pinion.gg
  stage.pinion.gg
  templ4d2.pinion.gg
  tix.pinion.gg
  transcoded.pinion.gg
  video.pinion.gg
  voip.pinion.gg
  wiki.pinion.gg
  www.pinion.gg
'

# The base ipsets
# Provides a basic amount of protection without breaking sites, or breaking
# only a minimal amount of sites
readonly base_ipset_sources="
    http://www.projecthoneypot.org/list_of_ips.php?t=d&rss=1
    https://check.torproject.org/cgi-bin/TorBulkExitList.py?ip=1.1.1.1
    https://www.maxmind.com/en/proxy-detection-sample-list
    http://danger.rulez.sk/projects/bruteforceblocker/blist.php
    https://www.spamhaus.org/drop/drop.lasso
    http://cinsscore.com/list/ci-badguys.txt
    https://www.openbl.org/lists/base.txt
    https://www.autoshun.org/files/shunlist.csv
    https://lists.blocklist.de/lists/all.txt
    https://www.stopforumspam.com/downloads/toxic_ip_cidr.txt
    http://blocklist.greensnow.co/greensnow.txt
"

# The sources that will be parsed into the ipset.
# By default only the sources in the ${base_sources} list
# are included, additional sources can be included by
# appending them onto lines following the base-sources line.
# Destinations and duplicate entries do not matter, as they will
# be sanitized and duplicates will be stripped out.
readonly ipset_sources="

  ${base_ipset_sources}

"
readonly ipset_whitelist='
127.0.0.1
0.0.0.0
255.255.255.255
'

# BLACKLIST IPS
# Only exact strings, no regex supported
readonly ipset_blacklist='
'

##
# Display a general message
##
action_msg()
{
  printf -- "%b + %b%s%b\n" "\033[1;33m" "\033[1;32m" "$1" "\033[0m"
}

##
# Display an error message
##
error_msg()
{
  printf -- "%b + %b%s%b\n" "\033[1;33m" "\033[1;31m" "$1" "\033[0m"
}

##
# Display an information snippet
##
info_msg()
{
  printf -- "   - %s\n" "$1"
}

##
# Check the environment path for the either wget or curl
# exit if it is not found
##
check_for_download_ability()
{
  if ! which curl > /dev/null 2>&1; then
    if ! which wget > /dev/null 2>&1; then
      printf -- "Either wget or curl are required for this script\n"
      printf -- "Please install either 'wget' or 'curl' onto your system.\n"
      return 1
    fi
  fi
}

##
# Check the environment path for the given binary, exit if it is not found
##
check_for_binary()
{
  if ! which "$1" > /dev/null 2>&1; then
    printf -- "The '%s' binary is required for this script.\n" "$1"
    printf -- "Please install '%s' onto your system.\n" "$1"
    return 1
  fi
}

##
# Print out the user configuration
##
print_config()
{
  info_msg "Hosts location: ${dst_hosts}"
  info_msg "Destination IP: ${dst_ip}"
}

##
# Decide what program to DL with
##
decide_dl_client()
{
  # Check for curl, if not found, use wget, as the check for either
  # Should have passed before this function
  local cmd=
  if which curl > /dev/null 2>&1; then
    cmd="curl -fsSL --connect-timeout 40 --max-time 60 -A 'Mozilla/5.0'"
  else
    cmd="wget -T 10 -qO- -A 'Mozilla/5.0'"
  fi
  printf -- "%s" "${cmd}"
  unset cmd
}

process_ipset_sources()
{
  # $1 tmpfile
  # $2 url
  # Process each tmpfile seperately
  change_eol "$1" "$2"
  select_ip_lines "$1" "$2"
}

process_hosts_sources()
{
  # $1 tmpfile
  # $2 url
  # Process each tmpfile seperately
  change_eol "$1" "$2"
  select_host_lines "$1" "$2"
  remove_untrusted_domain "$1" "$2"
  normalize_to_lowercase "$1" "$2"
  remove_local_entries "$1" "$2"
}

##
# hosts_sources list parsing
##
download_to_tempfile()
{
  # $1 cmd
  # $2 hook
  # $3 url
  # $4 tmpfile
  info_msg "Downloading from $3"
  local hostfile="$(printf -- "%s" "$($1 $3)")"
  if [ -z "${hostfile}" ]; then
    info_msg "  Failed to download from: $3"
    return
  fi

  # Guarantee an empty file
  printf -- "%s\n" "${hostfile}" > "$4"
  "$2" "$4" "$3"
}


##
# Download the source file from each URL specified in source
# Download runs in parallel in the background
##
download_sources()
{
  # $1 cmd
  # $2 sources
  # $3 process command
  for src in $2; do
    local current_temp_file=$(mktemp)
    temp_files="${current_temp_file} ${temp_files}"
    local url="${src}"
    download_to_tempfile "$1" "$3" "${url}" "${current_temp_file}" &
    pids="${pids} $!"
    unset url
  done

  # Wait for all parallel downloads to finish
  # Instead of taking a long time in total, this will only take as long
  # as it takes for the longest download to complete
  wait ${pids}

  # Write the contents of each download to the blocklist
  for f in ${temp_files}; do
    local content="$(cat $f)"
    if [ ! -z "${content}" ]; then
      if [ -z "${blocklist}" ]; then
        blocklist=$(printf -- "%s\n" "${content}")
      else
        blocklist=$(printf -- "%s\n%s\n" "${blocklist}" "${content}")
      fi
    fi

    # Remove the temp file
    rm -f "$f"
    unset content
  done
}

##
# Change EOL from DOS to Unix format
##
change_eol()
{
  # $1 file
  # $2 url
  info_msg "Change EOL to Unix format: $2 ($1)"
  sed -r -i 's/$//' "$1"
}

##
# Only select lines which contain a host, do not select comments/other
##
select_host_lines()
{
  # $1 file
  # $2 url
  info_msg "Select only hosts lines: $2 ($1)"
  local ip_regex='([0-9]{1,3}\.){3}[0-9]{1,3}[[:blank:]]+'
  local domain_regex='([[:alnum:]_-]{1,63}\.)+[[:alpha:]][[:alnum:]_-]{1,62}'

  # KLUDGE
  # This leaves trailing comments in lines, making it not as effective
  # sed -n -i -r "/(^(${ip_regex})|^)${domain_regex}/p" "$1"
  #
  # This is an ugly workaround
  local content="$(grep -oE "(^(${ip_regex})|^)${domain_regex}" "$1")"
  printf -- "$content" > "$1"
  unset content
  unset ip_regex domain_regex
}

##
# Only select lines which contain an ip, do not select comments/other
##
select_ip_lines()
{
  # $1 file
  # $2 url
  info_msg "Select only ip lines: $2 ($1)"
  local ip_regex='([0-9]{1,3}\.){3}[0-9]{1,3}'

  local content="$(grep -oE "${ip_regex}" "$1")"
  printf -- "${content}" > "$1"
  unset content ip_regex
}

##
# Remove any predefined destinations, as they may be untrustworthy
##
remove_untrusted_domain()
{
  # $1 file
  # $2 url
  info_msg "Remove old destination: $2 ($1)"
  sed -i -r 's/^([0-9]{1,3}\.){3}[0-9]{1,3}[[:space:]]+//g' "$1"
}

##
# Normalize all entries to lowercase strings
##
normalize_to_lowercase()
{
  # $1 file
  # $2 url
  info_msg "Transform all entries to lowercase: $2 ($1)"

  # KLUDGE
  # Awk for some reason stops parsing after 1024 lines
  # awk -v tf="$1" '{print tolower($0) > tf}' "$1"
  #
  # This is an ugly work around
  local content="$(awk '{print tolower($0)}' "$1")"
  printf -- "${content}" > "$1"
  unset content
}

##
# Remove any entries containing the localhost, as it will be added by
# the hosts_header later on
##
remove_local_entries()
{
  # $1 file
  # $2 url
  info_msg "Remove local entries: $2 ($1)"
  sed -n -i -r \
    '/^(localhost|localhost.localdomain|local|broadcasthost)$/!p' "$1"
}

##
# Apply the user hosts_whitelist
##
apply_whitelist()
{
  # $1 whitelist
  info_msg "Apply hosts_whitelist"
  if [ -z "${blocklist}" ]; then
    return 1
  fi

  for domain in $1; do
    blocklist=$(printf -- "%s\n" "${blocklist}" | sed -r "/${domain}/d")
  done
}

##
# Apply the user blacklist
##
apply_blacklist()
{
  # $1 blacklist
  info_msg "Apply hosts_blacklist"
  # Cache the hosts_blacklist domains so that the entire block list
  # does not have to be echoed each time.

  # Domains initialized as first hosts_blacklist entry
  local domains=""
  for domain in $1; do
    if [ -z "${domains}" ]; then
      domains="${domain}"
    else
      domains=$(printf -- "%s\n%s\n" "${domains}" "${domain}")
    fi
  done

  if [ -z "${blocklist}" ]; then
    blocklist=$(printf -- "%s\n" "${domains}")
  else
    blocklist=$(printf -- "%s\n%s\n" "${blocklist}" "${domains}")
  fi
  unset domains
}

##
# Remove duplicate entries
##
remove_duplicates()
{
  info_msg "Remove duplicate entries"
  blocklist=$(printf -- "%s\n" "${blocklist}" | awk '!a[$0]++')
}

##
# Sort the entries by string numerical value
##
sort_entries()
{
  info_msg "Sort entries"
  blocklist=$(printf -- "%s\n" "${blocklist}" | sort -n)
}

##
# Add the configured destination, by default the zero address
##
add_new_destination()
{
  info_msg "Add new destination"
  blocklist=$(printf -- "%s\n" "${blocklist}" | sed "s/^/${dst_ip} /g")
}

##
# Parse the hosts_header and create the new hosts file
##
generate_new_hosts_file()
{
  hosts_header=$(printf -- "# <hosts_header>%s# </hosts_header>\n" "${hosts_header}")
  hosts_header=$(printf -- "# %s\n%s\n" "$(date)" "${hosts_header}")
  hosts=$(printf -- "%s\n# <blocklist>\n%s\n# </blocklist>" \
    "${hosts_header}" "${blocklist}")
}

##
# Backup original file
##
backup_old_file()
{
  if [ -f "${dst_hosts}" ]; then
    info_msg "Creating backup of original hosts file..."
    "${needs_sudo}" cp "${dst_hosts}" "${dst_backup}" || {
      error_msg "Failed to copy to file ${dst_backup}"
      return 1
    }
  else
    info_msg "No original file exists to create backup"
  fi
}

##
# Install the new hosts file to the destination
##
install_new_hosts_file()
{
  info_msg "Installing new hosts file..."
  printf -- "%s\n" "${hosts}" | "${needs_sudo}" tee "${dst_hosts}" > /dev/null || {
    error_msg "Failed to output to file ${dst_hosts}"
    return 1
  }
}

install_ipset_blocklist()
{
  action_msg "Install the ipset blocklist"

  info_msg "Clear existing block list"
  printf -- "" | "${needs_sudo}" tee "${ipset_file}" > /dev/null
  "${needs_sudo}" ipset flush "${ipset_name}"

  info_msg "Create new blocklist"
  # Save here just to get the create line
  "${needs_sudo}" ipset save "${ipset_name}" -file "${ipset_file}"

  info_msg "Add new IPs to the block list"
  blocklist=$(printf -- "%s\n" "${blocklist}" | sed -e 's/^/add blocklist /')
  printf -- "%s\n" "${blocklist}" | "${needs_sudo}" tee -a "${ipset_file}" > /dev/null || {
    error_msg "Failed to add ipset to blocklist"
    exit 1
  }

  info_msg "Commit new ipset"
  "${needs_sudo}" ipset restore -exist -file "${ipset_file}"
}


##
# Fixes permission on file to 644
##
fix_file_permissons()
{
  if [ -f "$1" ]; then
    info_msg "Fixing permissions for file $1..."
    "${needs_sudo}" chmod 644 "$1" || {
      error_msg "Failed to chmod $1"
      return 1
    }
  else
    info_msg "Cannot fix permission for non-existant file $1"
  fi
}

create_backup_name()
{
  # $1 file name
  printf -- "$1.backup.$(date +%Y%m%d)"
}

##
# Print the differences between the number of lines in each file
##
print_file_differences()
{
  # $1 new
  # $2 old
  local old_number=
  if [ -f "$2" ]; then
    old_number=$(wc -l < "$2")
  else
    old_number=0
  fi
  local new_number=$(wc -l < "$1")
  printf -- "%b + %b%s %bentries added! (%b + %b%s %b)\n" \
    "\033[1;33m" "\033[1;32m" "${new_number}" \
    "\033[0m" "\033[1;32m" "\033[1;34m" \
    "$((new_number - old_number))" "\033[0m"
  unset old_number new_number
}

remove_all_backup_files()
{
  # $1 normal file
  for arg in "$1".backup.*; do
    info_msg "Removing backup file: ${arg}..."
    "${needs_sudo}" rm -f "${arg}" > /dev/null 2>&1
  done
}

print_file_diff()
{
  # Check for the DIFF environment variable
  # Conditional assignment works when using the set -u option
  : "${DIFF:=diff}"

  if [ -f "${dst_hosts}" ] && [ -f "${dst_backup}" ]; then

    # Using the pager requires extra binary
    check_for_binary "${DIFF}"
    action_msg "Displaying diff of ${dst_backup} and "${dst_hosts} using "${DIFF}"

    "${DIFF}" -u "${dst_backup}" "${dst_hosts}"
  else
    error_msg "Cannot diff ${dst_backup} and ${dst_hosts} using ${DIFF}"
  fi
}

display_hosts_in_pager()
{
  # Check for the PAGER environment variable
  # Conditional assignment works when using the set -u option
  : "${PAGER:=less}"

  if [ -f "${dst_hosts}" ]; then

    # Using the pager requires extra binary
    check_for_binary "${PAGER}"
    action_msg "Displaying ${dst_hosts} in ${PAGER}..."

    "${PAGER}" "${dst_hosts}"
  else
    error_msg "File ${dst_hosts} does not exist. Cannot output to ${PAGER}"
  fi
}

sudoloop()
{
  touch "${sudolock}"
  while [ -e "${sudolock}" ]; do
    sudo -n -v
    sleep 2
  done
}

cleanup()
{
  # Kill runaway pids
  for p in ${pids}; do
    kill "${p}" > /dev/null 2>&1
  done

  # rm leftover files
  for temp in ${temp_files}; do
    rm -f "${temp}" > /dev/null 2>&1
  done

  blocklist=""
  pids=""
  temp_files=""
}

cancel_sudoloop()
{
  [ -e "${sudolock}" ] && rm -f "${sudolock}"

  cleanup

  exit 0
}

print_version()
{
  printf -- "update-hosts[${version}]\n"
  echo
}


# Script begins here
dst_hosts="/etc/hosts"

# Check for required binaries, exit out if they are not present
check_for_download_ability || exit 1
check_for_binary sed || exit 1
check_for_binary grep || exit 1
check_for_binary sort || exit 1
check_for_binary touch || exit 1
check_for_binary sleep || exit 1
check_for_binary rm || exit 1
check_for_binary awk || exit 1
check_for_binary tee || exit 1
check_for_binary cp || exit 1
check_for_binary wc || exit 1
check_for_binary printf || exit 1
check_for_binary chmod || exit 1
check_for_binary mktemp || exit 1
check_for_binary cat || exit 1

# Handle options
# Options
#   -h | --help     Display help
#   -v | --version  Display version
#   -r | --remove   Remove backups
#   -p | --pager    Display hosts file in pager
#   -o | --output   The file to output to
#   -n | --noroot   Do not require root to output.
for arg in $@; do
  case "${arg}" in
    "-h"|"--help")
      print_version
      printf -- "  Options:\n"
      printf -- "     -h | --help     Display help\n"
      printf -- "     -v | --version  Display version\n"
      printf -- "     -r | --remove   Remove backups\n"
      printf -- "     -p | --pager    Display hosts file in pager\n"
      printf -- "     -o | --output   The file to output to\n"
      printf -- "     -n | --noroot   Do not require root to output\n"
      printf -- "     -d | --diff     Display a diff of the output file\n"
      exit 0
      ;;
    "-v"|"--version")
      print_version
      exit 0
      ;;
    "-r"|"--remove")
      remove_backups=1
      shift
      ;;
    "-p"|"--pager")
      display_pager=1
      shift;
      ;;
    "-o"|"--output")
      shift
      if [ $# -ge 1 ]; then
        if  [ -z "$1" ]; then
          printf -- "Must specify an output file.\n"
          exit 1
        else
          dst_hosts="$1"
          shift
        fi
      else
        printf -- "Must specify an output file.\n"
        exit 1
      fi
      ;;
    "-n"|"--noroot")
      require_root=0
      shift
      ;;
    "-d"|"--diff")
      diff_file=1;
      shift
      ;;
  esac
done

# Check if pager is set
# TODO Add support for a $PAGER variable
if [ "${display_pager}" -eq 1 ]; then
  display_hosts_in_pager

  action_msg "Exiting..."
  # Clean exit
  exit 0
fi

# Trap exit signals
trap cancel_sudoloop INT

needs_sudo=
if [ "$(id -u)" -ne 0 ] && [ "${require_root}" -eq 1 ]; then
  check_for_binary sudo

  # initialize sudo
  sudo -v || exit 1

  # Start sudoloop
  sudoloop &

  needs_sudo="sudo"
else
  needs_sudo=""
fi

# Process begins:
action_msg "Configuration:"
print_config

# Download
action_msg "Downloading hosts_sources lists..."
download_sources "$(decide_dl_client)" "${hosts_sources}" "process_hosts_sources" || cancel_sudoloop

# Parse
action_msg "Generating hosts file..."
apply_whitelist "${hosts_whitelist}" || cancel_sudoloop
apply_blacklist "${hosts_blacklist}" || cancel_sudoloop
remove_duplicates || cancel_sudoloop
sort_entries || cancel_sudoloop
add_new_destination || cancel_sudoloop

# Install
generate_new_hosts_file || cancel_sudoloop
dst_backup=$(create_backup_name "${dst_hosts}" ) || cancel_sudoloop
backup_old_file || cancel_sudoloop
install_new_hosts_file || cancel_sudoloop
fix_file_permissons "${dst_hosts}" || cancel_sudoloop
fix_file_permissons "${dst_backup}" || cancel_sudoloop
print_file_differences "${dst_hosts}" "${dst_backup}" || cancel_sudoloop
if [ "${diff_file}" -eq 1 ]; then
  print_file_diff "${dst_backup}" "${dst_hosts}" || cancel_sudoloop
fi

# Cleanup
if [ "${remove_backups}" -eq 1 ]; then
  remove_all_backup_files "${dst_hosts}" || cancel_sudoloop
fi

# Start fresh
cleanup

# Download
printf -- "\n\n"
action_msg "Downloading ipset_sources lists..."
download_sources "$(decide_dl_client)" "${ipset_sources}" "process_ipset_sources" || cancel_sudoloop

# Parse
action_msg "Generating ipset..."
apply_whitelist "${ipset_whitelist}" || cancel_sudoloop
apply_blacklist "${ipset_blacklist}" || cancel_sudoloop
remove_duplicates || cancel_sudoloop
sort_entries || cancel_sudoloop

# Install
dst_backup=$(create_backup_name "${ipset_file}" ) || cancel_sudoloop
backup_old_file || cancel_sudoloop
install_ipset_blocklist || cancel_sudoloop
fix_file_permissons "${ipset_file}" || cancel_sudoloop
fix_file_permissons "${dst_backup}" || cancel_sudoloop
print_file_differences "${ipset_file}" "${dst_backup}" || cancel_sudoloop

if [ "${remove_backups}" -eq 1 ]; then
  remove_all_backup_files "${ipset_file}" || cancel_sudoloop
fi
cancel_sudoloop

# vim: set syntax=sh tabstop=2 softtabstop=2 shiftwidth=2 shiftround expandtab:

