#!/bin/sh

#
#  The MIT License (MIT)
#
#  Copyright (c) 2015 - 2016 Peter Kenji Yamanaka
#  Copyright (c) 2015 Héctor Molinero Fernández
#
#  Permission is hereby granted, free of charge, to any person obtaining a copy
#  of this software and associated documentation files (the "Software"), to deal
#  in the Software without restriction, including without limitation the rights
#  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#  copies of the Software, and to permit persons to whom the Software is
#  furnished to do so, subject to the following conditions:
#
#  The above copyright notice and this permission notice shall be included in all
#  copies or substantial portions of the Software.
#
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#  SOFTWARE.

# Author:
#  Héctor Molinero Fernández <me@znt.se>.
#
# Modified by:
#  pyamsoft <pyam(dot)soft(at)gmail(dot)com>

# Will cause calls to
#
# $ sh update-hosts
#
# to fail.
#
# Prevent the script from being sourced
# if [ "$(basename "$_")" != "update-hosts" ]; then
#   # Return, script was sourced
#   return 0
# fi

# Configuration:

# Version
VERSION="2.3.1"

readonly SUDOLOCK="/tmp/update-hosts.sudolock"

# Set a sanitized PATH
# Do not include /usr/local
PATH="/usr/sbin:/usr/bin:/sbin:/bin"
export PATH

# NOTE: Adding the alias of the 0 domain to itself fixes a display issue that
#       can occur when using traceroute, netstat and the like.
#
# NOTE: This header will be directly inserted into the generated hosts file.
#       We intentionally leave the spacing as is.
#
# Do some additional checking in case the hostname is localhost so we
# do not include it twice
machine_hostname="$(uname -n)"
if [ "${machine_hostname}" != "localhost" ]; then
  machine_hostname="${machine_hostname} localhost"
fi

readonly HOSTS_HEADER="
127.0.0.1 ${machine_hostname}
# Fixes a display anomaly in traceroute and netstat
0.0.0.0 0.0.0.0
"
unset machine_hostname

# The base hosts_sources
# Provides a basic amount of protection without breaking sites, or breaking
# only a minimal amount of sites
readonly BASE_HOSTS_SOURCES="
  # HTTP Sources
  http://winhelp2002.mvps.org/hosts.txt
  http://someonewhocares.org/hosts/hosts
  http://malwaredomains.lehigh.edu/files/justdomains
  http://mirror1.malwaredomains.com/files/immortal_domains.txt

  # HTTPS Sources
  https://adaway.org/hosts.txt
  https://www.malwaredomainlist.com/hostslist/hosts.txt
  https://pgl.yoyo.org/adservers/serverlist.php?hostformat=hosts&mimetype=plaintext
  https://s3.amazonaws.com/lists.disconnect.me/simple_ad.txt
  https://s3.amazonaws.com/lists.disconnect.me/simple_malvertising.txt
  https://s3.amazonaws.com/lists.disconnect.me/simple_malware.txt
  https://s3.amazonaws.com/lists.disconnect.me/simple_tracking.txt
"

# Additional hosts file servers
# readonly additonal_hosts_sources="
#   https://ransomwaretracker.abuse.ch/downloads/RW_DOMBL.txt
#   https://zeustracker.abuse.ch/blocklist.php?download=domainblocklist
# "

# Hosts-file.net server classifications
# Provides more in-depth protection and host blocking at the cost of
# breaking some sites
#
# readonly hosts_file_net_parts="
#   https://hosts-file.net/ad_servers.txt
#   https://hosts-file.net/emd.txt
#   https://hosts-file.net/exp.txt
#   https://hosts-file.net/fsa.txt
#   https://hosts-file.net/hjk.txt
#   https://hosts-file.net/mmt.txt
#   https://hosts-file.net/psh.txt
# "

# These entries are very large, and may break certain sites
# that rely on CDNs or third party hosts_sources
# Instead of downloading the entire hosts file and additional parts
# the split download above is recommended. The parts that you do not
# desire can be ignored individually instead of an all or nothing approach.
# The two hosts_sources below are generally not recommended nor needed. If you
# wish to use them, be sure to comment out the above hosts-file.net entries
# or you will largely be pulling duplicate hosts_sources.
#
# readonly hosts_file_net_full="
#   http://hosts-file.net/download/hosts.txt
#   http://hosts-file.net/hphosts-partial.txt
# "


# The hosts_sources that will be parsed into the hosts file.
# By default only the hosts_sources in the ${BASE_HOSTS_SOURCES} list
# are included, additional hosts_sources can be included by
# appending them onto lines following the base-hosts_sources line.
# Destinations and duplicate entries do not matter, as they will
# be sanitized and duplicates will be stripped out.
readonly HOSTS_SOURCES="

  ${BASE_HOSTS_SOURCES}

"

# Regex allowed
#  '\.com$'   -> all domains that end with '.com'
#  '^example' -> all domains that start with 'example'
#  '^sub.\example\.org$' -> literal domain 'sub.exmaple.org'

# Due to the binary yes or no nature of hosts file, all of the domains that
# relate in some way to the uBlock0 Unbreak list will be added here.
# This is to allow uBlock0 to block the specific parts of the domains, while
# not breaking other sites that actually rely on them
# Though not a great solution, this seems to be the only way to get around
# some sites breaking when blocking certain hosts
#
# Because we cannot guarantee that the domains shipped in the whitelist
# are the full domain names, we do not qualify them with '^'
#
# Update 2016/10/15
readonly UNBREAK_WHITELIST='
  google-analytics\.com$
  analytics\.google\.com$
  adf\.ly$
  widget-cdn\.rpxnow\.com$
  tags\.tiqcdn\.com$
  statcounter\.com$
  cdn-static\.liverail\.com$
  vox-static\.liverail\.com$
  s0\.2mdn\.net$
  cdn-i\.dmdentertainment\.com$
  cdn\.vurb\.com$
  target\.122\.2o7\.net$
  adm\.fwmrm\.net$
  mopub\.com$
  safelinking\.net$
  outbrain\.com$
  inc\.com$
  flurry\.com$
  c\.speedtest\.net$
  boldchat\.com$
  mixpanel\.com$
  charlie\.strim.io$
  ovh\.strim.io$
  dn\.turner\.com$
  yui\.yahooapis\.com$
  top\.mail\.ru$
  css\.washingtonpost\.com$
  pcekspert\.com$
  clickbank\.com$
  yandex\.ru$
  yastatic\.net$
  carbonads\.net$
  imasdk\.googleapis\.com$
  2o7\.net$
  quantcast\.com$
  css5\.gaanacdn\.com$
  keen\.github\.io$
  cdn\.phoenix\.intergi\.com$
  kissmetrics\.com$
  viewpoint\.com$
  woopra\.com$
  monetate\.net$
  googleads\.g\.doubleclick\.net$
  img\.echohosting\.cafe24\.com$
  googletagmanager\.com$
  partner\.googleadservices\.com$
  pagefair\.com$
  ssl\.cdn-redfin\.com$
  www\.southwest\.com$
  marketwatch\.com$
  cloudfront\.net$
  nationalreview\.com$
  liveperson\.net$
  taboola\.com$
  ticketmaster\.122\.2o7\.net$
  phoronix\.com$
  files\.explosm\.net$
  cdn\.segment\.com$
  sorted\.org$
  analytics\.edgekey\.net$
  tfag\.de$
  ^nav\.files\.bbci\.co\.uk$
  gamespot\.com$
  umbro\.com$
  shop\.puppetlabs\.com$
  flightradar24\.com$
  premium\.soundcloud\.com$
  stats\.bbc\.co\.uk$
  snoobi\.com$
  esellerate\.net$
  dw\.cbsi\.com$
  data\.netscope\.marktest\.pt$
  gapt.\hit\.gemius\.pl$
  naiadsystems\.com$
  static\.adf\.ly$
  emarketer\.com$
  tapad\.com$
  staticxx\.facebook\.com$
  sp\.computershopper\.com$
  localytics\.com$
  p\.jwpcdn\.com$
  media2\.intoday\.in$
  styletagassets\.com$
  outlook\.live\.com$
  uim\.tifbs\.net$
'

# User defined whitelist
readonly USER_WHITELIST='
'

# Add any of your own custom whitelist modifications to the USER_WHITELIST
# variable
#
# As of version 2.2.0, unbreak list is not added by default
# ${UNBREAK_WHITELIST}
HOSTS_WHITELIST="
  ${USER_WHITELIST}
"

# Jump scare websites
# Only exact strings, no regex supported
readonly JUMPSCARE_BLACKLIST='
  agor.io
  www.agor.io
'

# CSGO Ads
# Only exact strings, no regex supported
readonly ADVERTISEMENT_BLACKLIST='
  adback.pinion.gg
  api.pinion.gg
  bin.pinion.gg
  blog.pinion.gg
  bork.pinion.gg
  calendar.pinion.gg
  cdn.pinion.gg
  cp.pinion.gg
  crm.pinion.gg
  delivery.pinion.gg
  direct.pinion.gg
  docs.pinion.gg
  immuniser.pinion.gg
  kermit.pinion.gg
  legacy.pinion.gg
  log.pinion.gg
  mail.pinion.gg
  mailer.pinion.gg
  motd.pinion.gg
  ns1.pinion.gg
  ns2.pinion.gg
  ns3.pinion.gg
  ns4.pinion.gg
  ns5.pinion.gg
  ns6.pinion.gg
  office.pinion.gg
  oscar.pinion.gg
  pinion-log.pinion.gg
  pinion.gg
  pog.pinion.gg
  quartermaster.pinion.gg
  seen.pinion.gg
  stage.pinion.gg
  templ4d2.pinion.gg
  tix.pinion.gg
  transcoded.pinion.gg
  video.pinion.gg
  voip.pinion.gg
  wiki.pinion.gg
  www.pinion.gg
'

# Any websites that may be deemed unsafe for various reasons
# Things like phishing, malvertising, malware and so forth
readonly BAD_SITE_BLACKLIST='
  com.com
  01net.com
  chip.de
  download.cnet.com
  sourceforge.net
  softonic.com
  flexytalk.net
  quickdomainfwd.com
'

# User defined blacklist
# Only exact strings, no regex supported
readonly USER_BLACKLIST='
'

# hosts_blacklist DOMAINS
# Only exact strings, no regex supported
readonly HOSTS_BLACKLIST="
  ${JUMPSCARE_BLACKLIST}
  ${ADVERTISEMENT_BLACKLIST}
  ${BAD_SITE_BLACKLIST}
  ${USER_BLACKLIST}
"

# The base ipsets
# Provides a basic amount of protection without breaking sites, or breaking
# only a minimal amount of sites
readonly BASE_IPSET_SOURCES="
  # HTTP Sources
  http://www.projecthoneypot.org/list_of_ips.php?t=d&rss=1
  http://cinsscore.com/list/ci-badguys.txt
  http://blocklist.greensnow.co/greensnow.txt
  http://www.openbl.org/lists/base.txt

  # HTTPS Sources
  https://www.autoshun.org/files/shunlist.csv
  https://lists.blocklist.de/lists/all.txt
  https://www.stopforumspam.com/downloads/toxic_ip_cidr.txt
  https://www.spamhaus.org/drop/drop.lasso
  https://check.torproject.org/cgi-bin/TorBulkExitList.py?ip=1.1.1.1
  https://www.maxmind.com/en/proxy-detection-sample-list
"

# Other ipset sources
#
# http://danger.rulez.sk/projects/bruteforceblocker/blist.php

# The sources that will be parsed into the ipset.
# By default only the sources in the ${base_sources} list
# are included, additional sources can be included by
# appending them onto lines following the base-sources line.
# Destinations and duplicate entries do not matter, as they will
# be sanitized and duplicates will be stripped out.
readonly IPSET_SOURCES="

  ${BASE_IPSET_SOURCES}

"
readonly IPSET_WHITELIST='
  127.0.0.1
  0.0.0.0
  255.255.255.255
'

# BLACKLIST IPS
# Only exact strings, no regex supported
readonly IPSET_BLACKLIST='
'

##
# Display a general message
##
action_msg()
{
  action_msg__message="$1"

  printf -- "%b + %b%s%b\n" \
    "\033[1;33m" \
    "\033[1;32m" \
    "${action_msg__message}" \
    "\033[0m"

  unset action_msg__message
  return 0
}

##
# Display an error message
##
error_msg()
{
  error_msg__message="$1"

  printf -- "%b + %b%s%b\n" \
    "\033[1;33m" \
    "\033[1;31m" \
    "${error_msg__message}" \
    "\033[0m"

  unset error_msg__message
  return 0
}

##
# Display an information snippet
##
info_msg()
{
  info_msg__message="$1"

  printf -- "   - %s\n" \
    "${info_msg__message}"

  unset info_msg__message
  return 0
}

##
# Check the environment path for the either wget or curl
# return if it is not found
##
check_for_download_ability()
{
  if ! which curl > /dev/null 2>&1; then
    if ! which wget > /dev/null 2>&1; then
      printf -- "Either wget or curl are required for this script\n"
      printf -- "Please install either 'wget' or 'curl' onto your system.\n"

      return 1
    fi
  fi

  return 0
}

##
# Check the environment path for the given binary, return if it is not found
#
# $1 the binary to check on the PATH
##
check_for_binary()
{
  check_for_binary__bin="$1"
  check_for_binary__old_ifs="${IFS}"
  if [ -z "${check_for_binary__bin}" ]; then
    error_msg "Must specify a path to a binary"
    return 1
  fi

  IFS=":"
  for check_for_binary__path in ${PATH}; do
    if [ -n "${check_for_binary__path}" ]; then
      check_for_binary__result=
      check_for_binary__result="${check_for_binary__path}/${check_for_binary__bin}"
      if [ -e "${check_for_binary__result}" ]; then
        IFS="${check_for_binary__old_ifs}"

        unset check_for_binary__result
        unset check_for_binary__bin
        unset check_for_binary__old_ifs
        unset check_for_binary__path
        return 0
      fi

      unset check_for_binary__result
    fi
  done

  error_msg "Binary '${check_for_binary__bin}' not found in \$PATH"

  unset check_for_binary__result
  unset check_for_binary__bin
  unset check_for_binary__old_ifs
  unset check_for_binary__path
  return 1
}

##
# Print out the hosts configuration
#
# $1 hosts file location
# $2 hosts destination IP
##
print_hosts_config()
{
  print_hosts_config__file="$1"
  print_hosts_config__ip="$2"

  action_msg "Hosts Configuration:"
  info_msg "Hosts location: ${print_hosts_config__file}"
  info_msg "Destination IP: ${print_hosts_config__ip}"

  unset print_hosts_config__file
  unset print_hosts_config__ip
  return 0
}

##
# Print out the ipset configuration
#
# $1 sudo or blank if not needed
# $2 ipset file location
# $3 ipset name
##
print_ipset_config()
{
  print_ipset_config__sudo="$1"
  print_ipset_config__file="$2"
  print_ipset_config__name="$3"

  action_msg "Ipset Configuration:"
  info_msg "Ipset location: ${print_ipset_config__file}"
  info_msg "Ipset name: ${print_ipset_config__name}"

  # The ipset must exist first for this script to work
  # check for existence here
  ${print_ipset_config__sudo} ipset \
    list "${print_ipset_config__name}" > /dev/null 2>&1 || {
    action_msg "Ipset ${print_ipset_config__name} does not exist, creating it"

    # Make the ipset
    ${print_ipset_config__sudo} ipset create "${print_ipset_config__name}" hash:net
  }

  unset print_ipset_config__sudo
  unset print_ipset_config__file
  unset print_ipset_config__name
  return 0
}

##
# Decide what program to DL with
#
# Echoes the name of the program to use as an HTTP client for downloading the
# sources
##
decide_dl_client()
{
  # Check for curl, if not found, use wget, as the check for either
  # Should have passed before this function
  decide_dl_client__cmd=

  if which curl > /dev/null 2>&1; then
    decide_dl_client__cmd="$(cat << EOF
curl -fsSL --connect-timeout 40 --max-time 60 -A 'Mozilla/5.0'
EOF
)"
  else
    decide_dl_client__cmd="$(cat << EOF
wget -T 10 -qO- -A 'Mozilla/5.0'
EOF
)"
  fi

  # Echo before unsetting
  printf -- "%s" "${decide_dl_client__cmd}"

  unset decide_dl_client__cmd
  return 0
}

##
# Process each temporary Ipset source file
#
# $1 temporary file location
# $2 source url
##
process_ipset_sources()
{
  process_ipset_sources__file="$1"
  process_ipset_sources__url="$2"

  change_eol "${process_ipset_sources__file}" \
    "${process_ipset_sources__url}"
  remove_comments "${process_ipset_sources__file}" \
    "${process_ipset_sources__url}"
  trim_whitespace "${process_ipset_sources__file}" \
    "${process_ipset_sources__url}"
  select_ip_lines "${process_ipset_sources__file}" \
    "${process_ipset_sources__url}"

  unset process_ipset_sources__file
  unset process_ipset_sources__url
  return 0
}

##
# Process each temporary hosts source file
#
# $1 temporary file location
# $2 source url
##
process_hosts_sources()
{
  process_hosts_sources__file="$1"
  process_hosts_sources__url="$2"

  change_eol "${process_hosts_sources__file}" \
    "${process_hosts_sources__url}"
  remove_comments "${process_hosts_sources__file}" \
    "${process_hosts_sources__url}"
  trim_whitespace "${process_hosts_sources__file}" \
    "${process_hosts_sources__url}"
  select_host_lines "${process_hosts_sources__file}" \
    "${process_hosts_sources__url}"
  remove_untrusted_domain "${process_hosts_sources__file}" \
    "${process_hosts_sources__url}"
  normalize_to_lowercase "${process_hosts_sources__file}" \
    "${process_hosts_sources__url}"
  remove_local_entries "${process_hosts_sources__file}" \
    "${process_hosts_sources__url}"

  unset process_hosts_sources__file
  unset process_hosts_sources__url
  return 0
}

##
# Parse the hosts file together from the various sources
#
# $1 The HTTP client to use
# $2 The URL of the source
# $3 The temporary file location
# $4 The command to run after downloading, begins with process_*
##
download_to_tempfile()
{
  download_to_tempfile__client="$1"
  download_to_tempfile__url="$2"
  download_to_tempfile__file="$3"
  download_to_tempfile__process_hook="$4"
  download_to_tempfile__content=

  info_msg "Downloading from ${download_to_tempfile__url}"
  download_to_tempfile__content="$(printf -- "%s" \
    "$(${download_to_tempfile__client} "${download_to_tempfile__url}")")"
  if [ -z "${download_to_tempfile__content}" ]; then
    info_msg "  Failed to download from: ${download_to_tempfile__url}"
    return 1
  fi

  # Guarantee an empty file
  printf -- "%s\n" "${download_to_tempfile__content}" \
    > "${download_to_tempfile__file}"

  # Run after download processing hook
  "${download_to_tempfile__process_hook}" \
    "${download_to_tempfile__file}" "${download_to_tempfile__url}"

  unset download_to_tempfile__client
  unset download_to_tempfile__process_hook
  unset download_to_tempfile__url
  unset download_to_tempfile__file
  unset download_to_tempfile__content
  return 0
}


##
# Download the source file from each URL specified in source
# Download runs in parallel in the background
#
# $1 The HTTP client to use
# $2 The sources list to download from
# $3 Name of the function to call after download, begins with process_*
##
download_sources()
{
  download_sources__client="$1"
  download_sources__sources="$2"
  download_sources__process_hook="$3"

  # Set the IFS to newlines only
  download_sources__old_ifs="${IFS}"
  IFS="
"
  for download_sources__url in ${download_sources__sources}; do
    # Set the IFS back to normal
    IFS="${download_sources__old_ifs}"

    # Trim spaces and strip comments
    download_sources__url="$(printf -- "%s" "${download_sources__url}" \
      | sed 's/^[[:blank:]]*//; s/[[:blank:]]*$//; s/#.*$//g')"
    if [ -n "${download_sources__url}" ]; then
      case "${download_sources__url}" in
        \#*)
          # Comments are skipped
          continue
          ;;
        *)
          download_sources__tempfile=
          download_sources__tempfile="$(mktemp)"

          # Add the tempfile to list of temporary files
          __temp_files="${download_sources__tempfile} "${__temp_files}

          download_to_tempfile "${download_sources__client}" \
            "${download_sources__url}" "${download_sources__tempfile}" \
            "${download_sources__process_hook}" &

          # Add the pid to list of pids
          __pids="${__pids} $!"

          unset download_sources__tempfile
          unset download_sources__url
          ;;
      esac
    fi

    # Set the IFS back to weird
    IFS="
"
  done

  # Set the IFS back to normal
  IFS="${download_sources__old_ifs}"

  # Wait for all parallel downloads to finish
  # Instead of taking a long time in total, this will only take as long
  # as it takes for the longest download to complete
  #
  # Do not quote so that this will split into a list, instead of a single,
  # space separated input
  # shellcheck disable=SC2086
  wait ${__pids}

  # Write the contents of each download to the blocklist
  for f in ${__temp_files}; do
    download_sources__tempfile_content=

    download_sources__tempfile_content="$(cat "$f")"
    if [ ! -z "${download_sources__tempfile_content}" ]; then
      if [ -z "${__blocklist}" ]; then
        __blocklist="$(printf -- "%s\n" \
          "${download_sources__tempfile_content}")"
      else
        __blocklist="$(printf -- "%s\n%s\n" \
          "${__blocklist}" \
          "${download_sources__tempfile_content}")"
      fi
    fi

    # Remove the temp file
    rm -f "$f"

    unset f
    unset download_sources__tempfile_content
  done

  unset download_sources__client
  unset download_sources__sources
  unset download_sources__process_hook
  return 0
}

##
# Change EOL from DOS to Unix format
#
# $1 file location
# $2 source url
##
change_eol()
{
  change_eol__file="$1"
  change_eol__url="$2"
  info_msg "$(cat << EOF
Change EOL to Unix format: ${change_eol__url} (${change_eol__file})
EOF
)"
  # Use tr instead of GNU sed extension
  change_eol__contents="$(tr -d '\r' < "${change_eol__file}")"
  printf -- "%s\n" "${change_eol__contents}" > "${change_eol__file}"

  unset change_eol__contents
  unset change_eol__file
  unset change_eol__url
  return 0
}

##
# Remove comments from files
#
# $1 file location
# $2 source url
##
remove_comments()
{
  remove_comments__file="$1"
  remove_comments__url="$2"
  info_msg "$(cat << EOF
Remove any comments from file: ${remove_comments__url} \
(${remove_comments__file})
EOF
)"

  # Removes comments from files
  remove_comments__contents="$(sed 's/#.*$//g' < "${remove_comments__file}")"
  printf -- "%s\n" "${remove_comments__contents}" > "${remove_comments__file}"

  unset remove_comments__contents
  unset remove_comments__file
  unset remove_comments__url
  return 0
}

##
# Remove whitespace from files
#
# $1 file location
# $2 source url
##
trim_whitespace()
{
  trim_whitespace__file="$1"
  trim_whitespace__url="$2"
  info_msg "$(cat << EOF
Remove any comments from file: ${trim_whitespace__url} \
(${trim_whitespace__file})
EOF
)"

  # Trim whitespace from lines
  trim_whitespace__contents="$(sed 's/[[:blank:]]*$//g; s/^[[:blank:]]*//g' \
    < "${trim_whitespace__file}")"

  # Remove empty lines
  trim_whitespace__contents="$(printf -- "%s" "${trim_whitespace__contents}" \
    | sed '/^$/d')"
  printf -- "%s\n" "${trim_whitespace__contents}" > "${trim_whitespace__file}"

  unset trim_whitespace__contents
  unset trim_whitespace__file
  unset trim_whitespace__url
  return 0
}

##
# Only select lines which contain a host, do not select comments/other
#
# $1 file location
# $2 source url
##
select_host_lines()
{
  select_host_lines__file="$1"
  select_host_lines__url="$2"


  # KLUDGE
  # This leaves trailing comments in lines, making it not as effective
  # sed -n -i -r "/(^(${ip_regex})|^)${domain_regex}/p" "$1"
  #
  # This is an ugly workaround
  info_msg "$(cat << EOF
Select only hosts lines: ${select_host_lines__url} \
(${select_host_lines__file})
EOF
)"

  readonly IP_REGEX='\([[:digit:]]\{1,3\}\.\)\{3\}[[:digit:]]\{1,3\}'
  readonly DOMAIN_REGEX='\([[:alnum:]_-]\{1,63\}\.\)\{1,\}[[:alpha:]][[:alnum:]_-]\{1,62\}'

  # sed -n is POSIX (man 1p sed)
  select_host_lines__content="$(sed -n \
    "/^\(${IP_REGEX}[[:blank:]]\{1,\}\)\{0,1\}${DOMAIN_REGEX}$/p" \
    < "${select_host_lines__file}")"

  # Echo out result
  printf -- "%s" "${select_host_lines__content}" > "${select_host_lines__file}"

  unset select_host_lines__file
  unset select_host_lines__url
  unset select_host_lines__content
  return 0
}

##
# Only select lines which contain an ip, do not select comments/other
#
# $1 file location
# $2 source url
##
select_ip_lines()
{
  select_ip_lines__file="$1"
  select_ip_lines__url="$2"

  info_msg "$(cat << EOF
Select only IP lines: ${select_ip_lines__url} (${select_ip_lines__file})
EOF
)"

  # Regex for ip addresses with an optional netmask
  readonly IP_CIDR_REGEX='^([[:digit:]]{1,3}\.){3}[[:digit:]]{1,3}($|/([[:digit:]]|[1-2][[:digit:]]|3[0-2]))$'

  select_ip_lines__content="$(sed -n "/^${IP_CIDR_REGEX}/p" \
    "${select_ip_lines__file}")"

  # Echo out result
  printf -- "%s" "${select_ip_lines__content}" > "${select_ip_lines__file}"

  unset select_ip_lines__content
  unset select_ip_lines__file
  unset select_ip_lines__url
  return 0
}

##
# Remove any predefined destinations, as they may be untrustworthy
#
# $1 file
# $2 url
##
remove_untrusted_domain()
{
  remove_untrusted_domain__file="$1"
  remove_untrusted_domain__url="$2"
  info_msg "$(cat << EOF
Remove old destination: ${remove_untrusted_domain__url} \
(${remove_untrusted_domain__file})
EOF
)"

  # Remove any domain that may be included in the downloaded file
  remove_untrusted_domain__content="$(sed 's/^.\{1,\}[[:blank:]]\{1,\}//g' \
    < "${remove_untrusted_domain__file}")"
  printf -- "%s" "${remove_untrusted_domain__content}" \
    > "${remove_untrusted_domain__file}"

  unset remove_untrusted_domain__content
  unset remove_untrusted_domain__file
  unset remove_untrusted_domain__url
  return 0
}

##
# Normalize all entries to lowercase strings
#
# $1 file
# $2 url
##
normalize_to_lowercase()
{
  normalize_to_lowercase__file="$1"
  normalize_to_lowercase__url="$2"
  info_msg "$(cat << EOF
Transform all entries to lowercase: ${normalize_to_lowercase__url} \
(${normalize_to_lowercase__file})
EOF
)"

  normalize_to_lowercase__content="$(tr '[:upper:]' '[:lower:]' \
    < "${normalize_to_lowercase__file}")"
  printf -- "%s" "${normalize_to_lowercase__content}" \
    > "${normalize_to_lowercase__file}"

  unset normalize_to_lowercase__file
  unset normalize_to_lowercase__url
  unset normalize_to_lowercase__content
  return 0
}

##
# Remove any entries containing the localhost, as it will be added by
# the hosts_header later on
#
# $1 file
# $2 url
##
remove_local_entries()
{
  remove_local_entries__file="$1"
  remove_local_entries__url="$2"

  info_msg "$(cat << EOF
Remove local entries: ${remove_local_entries__url} \
(${remove_local_entries__file})
EOF
)"

  # Remove any lines which include things like localhost, or localhost.localdomain
  readonly LOCAL_DOMAIN_REGEX='/\.\local[[:blank:]]*$/d'

  remove_local_entries__content="$(sed "${LOCAL_DOMAIN_REGEX}" \
    < "${remove_local_entries__file}")"
  printf -- "%s" "${remove_local_entries__content}" \
    > "${remove_local_entries__file}"

  unset remove_local_entries__content
  unset remove_local_entries__file
  unset remove_local_entries__url
  return 0
}

##
# Apply the user hosts_whitelist
#
# $1 whitelist
##
apply_whitelist()
{
  apply_whitelist__whitelist="$1"

  info_msg "Apply hosts_whitelist"
  if [ -z "${__blocklist}" ]; then
    error_msg "Block list is empty"
    return 1
  fi

  apply_whitelist__old_ifs="${IFS}"

  # Set IFS to newline
  IFS="
"
  for apply_whitelist__domain in ${apply_whitelist__whitelist}; do
    # Set IFS back to normal
    IFS="${apply_whitelist__old_ifs}"

    apply_whitelist__domain="$(printf -- "%s" "${apply_whitelist__domain}" \
      | sed 's/^[[:blank:]]*//; s/[[:blank:]]*$//; s/#.*$//g')"
    if [ -n "${apply_whitelist__domain}" ]; then
      case "${apply_whitelist__domain}" in
        \#*)
          # Skip comments
          continue
          ;;
        *)
          __blocklist="$(printf -- "%s\n" "${__blocklist}" \
            | sed "/${apply_whitelist__domain}/d")"
          unset apply_whitelist__domain
          ;;
      esac
    fi

    # Set IFS back to newline
    IFS="
"
  done

  # Set IFS back to normal
  IFS="${apply_whitelist__old_ifs}"

  unset apply_whitelist__whitelist
  return 0
}

##
# Apply the user blacklist
#
# $1 blacklist
##
apply_blacklist()
{
  apply_blacklist__blacklist="$1"

  info_msg "Apply hosts_blacklist"
  # Cache the hosts_blacklist domains so that the entire block list
  # does not have to be echoed each time.
  # Domains initialized as first hosts_blacklist entry
  apply_blacklist__domains=""

  apply_blacklist__old_ifs="${IFS}"

  # Set IFS to newline
  IFS="
"
  for apply_blacklist__domain in ${apply_blacklist__blacklist}; do
    # Set IFS back to normal
    IFS="${apply_blacklist__old_ifs}"

    apply_blacklist__domain="$(printf -- "%s" "${apply_blacklist__domain}" \
      | sed 's/^[[:blank:]]*//; s/[[:blank:]]*$//; s/#.*$//g')"
    if [ -n "${apply_blacklist__domain}" ]; then
      case "${apply_blacklist__domain}" in
        \#*)
          # Skip comments
          continue
          ;;
        *)
          if [ -z "${apply_blacklist__domains}" ]; then
            apply_blacklist__domains="${apply_blacklist__domain}"
          else
            apply_blacklist__domains="$(printf -- "%s\n%s\n" \
              "${apply_blacklist__domains}" \
              "${apply_blacklist__domain}")"
          fi
          ;;
      esac
    fi

    # Set IFS to newline
    IFS="
"
  done

  # Set IFS back to normal
  IFS="${apply_blacklist__old_ifs}"

  if [ -z "${__blocklist}" ]; then
    __blocklist="$(printf -- "%s\n" "${apply_blacklist__domains}")"
  else
    __blocklist="$(printf -- "%s\n%s\n" \
      "${__blocklist}" "${apply_blacklist__domains}")"
  fi

  unset apply_blacklist__domains
  unset apply_blacklist__blacklist
  return 0
}

##
# Remove duplicate entries
##
remove_duplicates()
{
  info_msg "Remove duplicate entries"
  __blocklist="$(printf -- "%s\n" "${__blocklist}" | uniq)"

  return 0
}

##
# Sort the entries by string numerical value
##
sort_entries()
{
  info_msg "Sort entries"
  __blocklist="$(printf -- "%s\n" "${__blocklist}" | sort)"

  return 0
}

##
# Add the configured destination, by default the zero address
#
# $1 desitination IP address
##
add_new_destination()
{
  add_new_destination__ip="$1"

  info_msg "Add new destination"
  __blocklist="$(printf -- "%s\n" "${__blocklist}" \
    | sed "s/^/${add_new_destination__ip} /g")"

  unset add_new_destination__ip
  return 0
}

##
# Parse the hosts_header and create the new hosts file
#
# Outputs the completed hosts file contents
##
generate_new_hosts_file()
{
  generate_new_hosts_file__header=

  generate_new_hosts_file__header="$(printf -- \
    "# <hosts_header>%s# </hosts_header>\n" "${HOSTS_HEADER}")"
  generate_new_hosts_file__header="$(printf -- "# %s\n%s\n" \
    "$(date)" \
    "${generate_new_hosts_file__header}")"

  printf -- "%s\n# <blocklist>\n%s\n# </blocklist>" \
    "${generate_new_hosts_file__header}" \
    "${__blocklist}"

  unset generate_new_hosts_file__header
  unset __blocklist
  return 0
}

##
# Backup original file
#
# $1 needs_sudo
# $2 file name
# $3 backup name
##
backup_old_file()
{
  backup_old_file__sudo="$1"
  backup_old_file__file="$2"
  backup_old_file__backup="$3"

  if [ -f "${backup_old_file__file}" ]; then
    info_msg "Creating backup of original file..."
    ${backup_old_file__sudo} cp \
      "${backup_old_file__file}" "${backup_old_file__backup}" || {
      error_msg "Failed to copy to file ${backup_old_file__backup}"

      unset backup_old_file__sudo
      unset backup_old_file__file
      unset backup_old_file__backup
      return 1
    }
  else
    info_msg "No original file exists to create backup"
  fi

  unset backup_old_file__sudo
  unset backup_old_file__file
  unset backup_old_file__backup
  return 0
}

##
# Install the new hosts file to the destination
#
# $1 needs_sudo
# $2 hosts file content
# $3 file destination location
##
install_new_hosts_file()
{
  install_new_hosts_file__sudo="$1"
  install_new_hosts_file__hosts="$2"
  install_new_hosts_file__destination="$3"

  info_msg "Installing new hosts file..."
  printf -- "%s\n" "${install_new_hosts_file__hosts}" \
    | ${install_new_hosts_file__sudo} tee \
    "${install_new_hosts_file__destination}" > /dev/null \
    || {
    error_msg "Failed to output to file ${install_new_hosts_file__destination}"

    unset install_new_hosts_file__sudo
    unset install_new_hosts_file__hosts
    unset install_new_hosts_file__destination
    return 1
  }

  unset install_new_hosts_file__sudo
  unset install_new_hosts_file__hosts
  unset install_new_hosts_file__destination
  return 0
}

##
# Installs the ipset into the file given and then commits to the
# named ipset
#
# $1 needs_sudo
# $2 ipset detination file
# $3 ipset name
install_ipset_blocklist()
{
  install_ipset_blocklist__sudo="$1"
  install_ipset_blocklist__file="$2"
  install_ipset_blocklist__name="$3"

  action_msg "Install the ipset blocklist"
  info_msg "Clear existing block list"
  printf -- "" \
    | ${install_ipset_blocklist__sudo} \
    tee "${install_ipset_blocklist__file}" > /dev/null
  ${install_ipset_blocklist__sudo} ipset \
    flush "${install_ipset_blocklist__name}"

  info_msg "Create new blocklist"
  # Save here just to get the create line
  ${install_ipset_blocklist__sudo} ipset save \
    "${install_ipset_blocklist__name}" \
    -file "${install_ipset_blocklist__file}"

  # Because we have a bunch of /32 addresses, we attempt to reduce the
  # size of the list by merging all the ones we can into different subnets
  check_for_binary iprange && {
    # If we have the iprange binary, run an optimization on the set
    info_msg "Optimize ipset using iprange to reduce entry count"
    __blocklist=$(printf -- "%s" "${__blocklist}" | iprange --ipset-reduce-entries 1)
  }

  info_msg "Add new IPs to the block list"
  __blocklist=$(printf -- "%s\n" "${__blocklist}" | sed 's/^/add blocklist /')
  printf -- "%s\n" "${__blocklist}" \
    | ${install_ipset_blocklist__sudo} tee \
    -a "${install_ipset_blocklist__file}" > /dev/null \
    || {
    error_msg "Failed to add ipset to blocklist"

    unset install_ipset_blocklist__sudo
    unset install_ipset_blocklist__file
    unset install_ipset_blocklist__name
    return 1
  }

  info_msg "Commit new ipset"
  ${install_ipset_blocklist__sudo} ipset restore \
    -exist -file "${install_ipset_blocklist__file}"

  unset install_ipset_blocklist__sudo
  unset install_ipset_blocklist__file
  unset install_ipset_blocklist__name
  return 0
}


##
# Fixes permission on file to 644
#
# $1 needs_sudo
# $2 file to fix
##
fix_file_permissons()
{
  fix_file_permissons__sudo="$1"
  fix_file_permissons__file="$2"

  if [ -f "${fix_file_permissons__file}" ]; then
    info_msg "Fixing permissions for file ${fix_file_permissons__file}..."
    ${fix_file_permissons__sudo} chmod 644 "${fix_file_permissons__file}" \
      || {
      error_msg "Failed to chmod ${fix_file_permissons__file} to 644"

      unset fix_file_permissons__sudo
      unset fix_file_permissons__file
      return 1
    }
  else
    info_msg "$(cat << EOF
Cannot fix permission for non-existant file ${fix_file_permissons__file}
EOF
)"
  fi

  unset fix_file_permissons__sudo
  unset fix_file_permissons__file
  return 0
}

##
# Create a backup file name by appending the current date
# $1 file name
create_backup_name()
{
  create_backup_name__file="$1"

  # Echo out file name
  printf -- "%s.backup.%s" "${create_backup_name__file}" "$(date +%Y%m%d)"

  unset create_backup_name__file
  return 0
}

##
# Print the differences between the number of lines in each file
#
# $1 new file
# $2 old file
##
print_file_differences()
{
  print_file_differences__new="$1"
  print_file_differences__old="$2"

  print_file_differences__old_number=0
  if [ -f "${print_file_differences__old}" ]; then
    print_file_differences__old_number=$(wc -l \
      < "${print_file_differences__old}")
  fi

  print_file_differences__new_number=
  print_file_differences__new_number=$(wc -l \
    < "${print_file_differences__new}")

  # Echo out the result
  printf -- "%b + %b%s %bentries added! (%b + %b%s %b)\n" \
    "\033[1;33m" "\033[1;32m" "${print_file_differences__new_number}" \
    "\033[0m" "\033[1;32m" "\033[1;34m" \
    "$((print_file_differences__new_number \
    - print_file_differences__old_number))" \
    "\033[0m"

  unset print_file_differences__old
  unset print_file_differences__new
  unset print_file_differences__old_number
  unset print_file_differences__new_number
  return 0
}

##
# Remove all backup files that start with the given pattern
#
# $1 needs_sudo
# $2 normal file name
remove_all_backup_files()
{
  remove_all_backup_files__sudo="$1"
  remove_all_backup_files__file="$2"
  for remove_all_backup_files__temp in \
    "${remove_all_backup_files__file}".backup.*; do
    remove_all_backup_files__temp="$(printf -- "%s" \
      "${remove_all_backup_files__temp}" \
      | sed 's/^[[:blank:]]*//' | sed 's/[[:blank:]]*$//')"
    if [ -n "${remove_all_backup_files__temp}" ]; then
      info_msg "Removing backup file: ${remove_all_backup_files__temp}..."
      ${remove_all_backup_files__sudo} rm -f \
        "${remove_all_backup_files__temp}" > /dev/null 2>&1
      unset remove_all_backup_files__temp
    fi
  done

  unset remove_all_backup_files__sudo
  unset remove_all_backup_files__file
  return 0
}

##
# While the script is running, continue to refresh sudo timer
# This should be run in the background
sudoloop()
{
  touch "${SUDOLOCK}"
  while [ -e "${SUDOLOCK}" ]; do
    sudo -n -v
    sleep 2
  done

  return 0
}

##
# Clean up any temp files and kill any processes that are still running
# Also clears any global variables that are used
cleanup()
{
  # Kill runaway pids
  for p in ${__pids}; do
    p="$(printf -- "%s" "${p}" \
      | sed 's/^[[:blank:]]*//' | sed 's/[[:blank:]]*$//')"
    if [ -n "${p}" ]; then
      kill "${p}" > /dev/null 2>&1
    fi
  done

  # rm leftover files
  for temp in ${__temp_files}; do
    temp="$(printf -- "%s" "${temp}" \
      | sed 's/^[[:blank:]]*//' | sed 's/[[:blank:]]*$//')"
    if [ -n "${temp}" ]; then
      rm -f "${temp}" > /dev/null 2>&1
    fi
  done

  unset __blocklist
  __blocklist=""

  unset __pids
  __pids=""

  unset __temp_files
  __temp_files=""

  return 0
}

##
# Cancels the sudoloop if it is running
# performs cleanup and then exits the script
cancel_sudoloop()
{
  [ -e "${SUDOLOCK}" ] && rm -f "${SUDOLOCK}"
  cleanup

  # Exit point
  exit 0
}

##
# Echoes out the current version held by the constant VERSION
print_version()
{
  printf -- "update-hosts[%s]\n" "${VERSION}"
  echo

  return 0
}

##
# Print out help
print_help()
{
  print_version
  printf -- "%s\n" "$(cat << EOF
Options:
   -h | --help     Display help
   -v | --version  Display version
   -r | --remove   Remove backups
   -n | --noroot   Do not require root to output
   -i | --ipset    Also download ipset sources
   -u | --unbreak  Auto apply the unbreak whitelist
   --output-hosts  The file to output hosts to
   --output-ipset  The file to output ipsets to
   --ipset-name    The name of the ipset
   --dest-ip       The destination IP to use
EOF
)"
  return 0
}

##
# Main function which handles the downloading of hosts files
#
# $1 needs_sudo
# $2 hosts file destination
# $3 destination IP address
# $4 remove backups
main_hosts()
{
  main_hosts__sudo="$1"
  main_hosts__file="$2"
  main_hosts__ip="$3"
  main_hosts__remove_backup="$4"

  # Configuration
  print_hosts_config "${main_hosts__file}" "${main_hosts__ip}"

  # Download
  action_msg "Downloading hosts_sources lists..."
  download_sources "$(decide_dl_client)" \
    "${HOSTS_SOURCES}" "process_hosts_sources" || cancel_sudoloop

  # Parse
  action_msg "Generating hosts file..."
  apply_whitelist "${HOSTS_WHITELIST}" || cancel_sudoloop
  apply_blacklist "${HOSTS_BLACKLIST}" || cancel_sudoloop
  remove_duplicates || cancel_sudoloop
  sort_entries || cancel_sudoloop
  add_new_destination "${main_hosts__ip}" || cancel_sudoloop

  # Install

  info_msg "Create new hosts file"
  hosts=
  hosts="$(generate_new_hosts_file)" || cancel_sudoloop
  main_hosts__file_backup="$(create_backup_name \
    "${main_hosts__file}")" || cancel_sudoloop
  backup_old_file "${main_hosts__sudo}" \
    "${main_hosts__file}" "${main_hosts__file_backup}" || cancel_sudoloop
  install_new_hosts_file "${main_hosts__sudo}" \
    "${hosts}" "${main_hosts__file}" || cancel_sudoloop
  fix_file_permissons "${main_hosts__sudo}" \
    "${main_hosts__file}" || cancel_sudoloop
  fix_file_permissons "${main_hosts__sudo}" \
    "${main_hosts__file_backup}" || cancel_sudoloop
  print_file_differences "${main_hosts__file}" \
    "${main_hosts__file_backup}" || cancel_sudoloop

  # Cleanup
  if [ "${main_hosts__remove_backup}" -eq 1 ]; then
    remove_all_backup_files "${main_hosts__sudo}" \
      "${main_hosts__file}" || cancel_sudoloop
  fi

  unset hosts
  unset main_hosts__sudo
  unset main_hosts__file
  unset main_hosts__file_backup
  unset main_hosts__ip
  unset main_hosts__remove_backup
  return 0
}

##
# Main function which handles the downloading of ipset files
#
# $1 needs_sudo
# $2 ipset file destination
# $3 ipset name
# $4 remove backups
main_ipsets()
{
  main_ipsets__sudo="$1"
  main_ipsets__file="$2"
  main_ipsets__name="$3"
  main_ipsets__remove_backup="$4"

  if [ -z "${main_ipsets__sudo}" ] && [ "$(id -u)" -ne 0 ]; then
    error_msg "ipset functionality requires root user privileges"
    return 1
  fi

  # Begin
  printf -- "\n\n"
  print_ipset_config "${main_ipsets__sudo}" \
    "${main_ipsets__file}" "${main_ipsets__name}" || return 1

  # Download
  action_msg "Downloading ipset_sources lists..."
  download_sources "$(decide_dl_client)" \
    "${IPSET_SOURCES}" "process_ipset_sources" || cancel_sudoloop

  # Parse
  action_msg "Generating ipset..."
  apply_whitelist "${IPSET_WHITELIST}" || cancel_sudoloop
  apply_blacklist "${IPSET_BLACKLIST}" || cancel_sudoloop
  remove_duplicates || cancel_sudoloop
  sort_entries || cancel_sudoloop

  # Install
  main_ipsets__file_backup=$(create_backup_name \
    "${main_ipsets__file}" ) || cancel_sudoloop
  backup_old_file "${main_ipsets__sudo}" \
    "${main_ipsets__file}" "${main_ipsets__file_backup}" || cancel_sudoloop
  install_ipset_blocklist "${main_ipsets__sudo}" \
    "${main_ipsets__file}" "${main_ipsets__name}" || cancel_sudoloop
  fix_file_permissons "${main_ipsets__sudo}" \
    "${main_ipsets__file}" || cancel_sudoloop
  fix_file_permissons "${main_ipsets__sudo}" \
    "${main_ipsets__file_backup}" || cancel_sudoloop
  print_file_differences "${main_ipsets__file}" \
    "${main_ipsets__file_backup}" || cancel_sudoloop

  # Cleanup
  if [ "${main_ipsets__remove_backup}" -eq 1 ]; then
    remove_all_backup_files "${main_ipsets__sudo}" \
      "${main_ipsets__file}" || cancel_sudoloop
  fi

  unset main_ipsets__sudo
  unset main_ipsets__file
  unset main_ipsets__name
  unset main_ipsets__file_backup
  unset main_ipsets__remove_backup
  return 0
}

main()
{

  # Options
  remove_backups=0
  require_root=1
  manage_ipsets=0
  apply_unbreak=0

  # Script begins here
  dst_hosts="/etc/hosts"
  dst_ipset="/etc/ipset.conf"
  ipset_name="blocklist"
  dst_ip="0.0.0.0"

  # Check for required binaries, return out if they are not present
  check_for_download_ability || return 1
  check_for_binary sed || return 1
  check_for_binary grep || return 1
  check_for_binary sort || return 1
  check_for_binary touch || return 1
  check_for_binary sleep || return 1
  check_for_binary rm || return 1
  check_for_binary tee || return 1
  check_for_binary tr || return 1
  check_for_binary cp || return 1
  check_for_binary wc || return 1
  check_for_binary printf || return 1
  check_for_binary chmod || return 1
  check_for_binary mktemp || return 1
  check_for_binary cat || return 1

  # Handle options
  # Options
  #   -h | --help     Display help
  #   -v | --version  Display version
  #   -r | --remove   Remove backups
  #   -n | --noroot   Do not require root to output.
  #   -i | --ipset    Also download ipset sources
  #   -u | --unbreak  Auto apply the Unbreak whitelist
  #   --output-hosts  The file to output hosts to
  #   --output-ipset  The file to output ipsets to
  #   --ipset-name    The name of the ipset
  #   --dest-ip       The destination IP to use
  #
  # While risky to call eval, this is one way to
  # emulate the bash indirect_expansion ability
  if [ $# -gt 0 ]; then
    long_option=""
    optind_expanded=
    eval optind_expanded="\$${OPTIND}"
    while [ -n "${optind_expanded}" ]; do
      while getopts ":hvrniu-:" option; do
        # Set only on long option with arg
        if [ -n "${long_option}" ]; then
          error_msg "Long option --${long_option} expects argument"
          return 1
        fi

        long_option=""
        case "${option}" in
          -)
            case "${OPTARG}" in
              help)
                print_help
                return 0
                ;;
              version)
                print_version
                return 0
                ;;
              remove)
                remove_backups=1
                ;;
              noroot)
                require_root=0
                ;;
              ipset)
                manage_ipsets=1
                ;;
              unbreak)
                apply_unbreak=1
                ;;
              output-hosts|output-ipset|ipset-name|dest-ip)
                long_option="${OPTARG}"
                ;;
              *)
                # We must provide our own error message in this case
                error_msg "Illegal option --${OPTARG}"
                print_help
                return 1
                ;;
            esac
            ;;
          h)
            print_help
            return 0
            ;;
          v)
            print_version
            return 0
            ;;
          r)
            remove_backups=1
            ;;
          n)
            require_root=0
            ;;
          i)
            manage_ipsets=1
            ;;
          u)
            apply_unbreak=1
            ;;
          *)
            error_msg "Illegal option -${OPTARG}"
            print_help
            return 1
            ;;
        esac
      done

      # Re-establish the current OPTIND target
      if [ $# -ge ${OPTIND} ]; then
        eval optind_expanded="\$${OPTIND}"
      else
        optind_expanded=""
      fi

      if [ -z "${optind_expanded}" ]; then
        if [ -n "${long_option}" ]; then
          error_msg "Long option --${long_option} expects argument"
          return 1
        else
          break
        fi
      else
        # This is a plain arg and should be handled by one of
        # the options which takes an argument
        case "${long_option}" in
          output-hosts)
            dst_hosts="${optind_expanded}"
            ;;
          output-ipset)
            dst_ipset="${optind_expanded}"
            ;;
          dest-ip)
            dst_ip="${optind_expanded}"
            ;;
          ipset-name)
            ipset_name="${optind_expanded}"
            ;;
        esac
      fi

      # Set back to null
      long_option=

      option_shift_count="${OPTIND}"
      while [ "$#" -lt "${option_shift_count}" ]; do
        option_shift_count=$((option_shift_count - 1))
      done

      # Need this here incase the loop doesn't run
      if [ "$#" -ge "${option_shift_count}" ]; then
        # Shift the options
        shift ${option_shift_count}
        OPTIND=1
      fi

      # Unset
      unset option_shift_count
    done
  fi

  # Trap return signals
  trap cancel_sudoloop INT

  needs_sudo=
  if [ "$(id -u)" -ne 0 ] && [ "${require_root}" -eq 1 ]; then
    check_for_binary sudo

    # initialize sudo
    sudo -v || return 1

    # Start sudoloop
    sudoloop &

    needs_sudo="sudo"
  else
    needs_sudo=""
  fi


  # Main process
  if [ "${apply_unbreak}" -eq 1 ]; then
    # Dynamically apply the unreak whitelist
    action_msg "You are applying the Unbreak whitelist!"
    info_msg "While this may fix many broken websites, it may also pose"
    info_msg "a potential privacy or security risk. Use at your own discretion"
    HOSTS_WHITELIST="
    ${UNBREAK_WHITELIST}
    ${HOSTS_WHITELIST}
    "
  fi

  # Parse hosts files
  main_hosts "${needs_sudo}" "${dst_hosts}" \
    "${dst_ip}" "${remove_backups}" || cancel_sudoloop

  if [ "${manage_ipsets}" -eq 0 ]; then
    # End here
    cancel_sudoloop
  fi

  # Start fresh
  cleanup

  check_for_binary ipset || cancel_sudoloop
  main_ipsets "${needs_sudo}" "${dst_ipset}" \
    "${ipset_name}" "${remove_backups}" || cancel_sudoloop

  # Finish
  cancel_sudoloop
}

# For more information about these particular options, see
#    https://stackoverflow.com/questions/13468481/when-to-use-set-e
set -u

# dash does not understand pipefail
#
# set -o pipefail

# Export the LC as the default C so that we do not run into locale based quirks
LC_ALL=C
export LC_ALL

__temp_files="" # Leave blank
__pids="" # Leave blank
__blocklist="" # Leave blank

main "$@"
# vim: set syntax=sh tabstop=2 softtabstop=2 shiftwidth=2 shiftround expandtab:
